package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/loms/internal/repository.LomsRepository -o ./mocks/loms_repository_minimock.go -n LomsRepositoryMock

import (
	"context"
	"route256/loms/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LomsRepositoryMock implements repository.LomsRepository
type LomsRepositoryMock struct {
	t minimock.Tester

	funcApplyOrderReservations          func(ctx context.Context, orderId int64) (err error)
	inspectFuncApplyOrderReservations   func(ctx context.Context, orderId int64)
	afterApplyOrderReservationsCounter  uint64
	beforeApplyOrderReservationsCounter uint64
	ApplyOrderReservationsMock          mLomsRepositoryMockApplyOrderReservations

	funcClearReservations          func(ctx context.Context, orderId int64) (err error)
	inspectFuncClearReservations   func(ctx context.Context, orderId int64)
	afterClearReservationsCounter  uint64
	beforeClearReservationsCounter uint64
	ClearReservationsMock          mLomsRepositoryMockClearReservations

	funcCreateOrder          func(ctx context.Context, userId domain.UserId) (i1 int64, err error)
	inspectFuncCreateOrder   func(ctx context.Context, userId domain.UserId)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mLomsRepositoryMockCreateOrder

	funcCreateOrderItems          func(ctx context.Context, orderId int64, items []domain.OrderItem) (err error)
	inspectFuncCreateOrderItems   func(ctx context.Context, orderId int64, items []domain.OrderItem)
	afterCreateOrderItemsCounter  uint64
	beforeCreateOrderItemsCounter uint64
	CreateOrderItemsMock          mLomsRepositoryMockCreateOrderItems

	funcCreateReservation          func(ctx context.Context, reservations []domain.Reservation) (err error)
	inspectFuncCreateReservation   func(ctx context.Context, reservations []domain.Reservation)
	afterCreateReservationCounter  uint64
	beforeCreateReservationCounter uint64
	CreateReservationMock          mLomsRepositoryMockCreateReservation

	funcGetOrderInfo          func(ctx context.Context, orderId int64) (op1 *domain.OrderInfo, err error)
	inspectFuncGetOrderInfo   func(ctx context.Context, orderId int64)
	afterGetOrderInfoCounter  uint64
	beforeGetOrderInfoCounter uint64
	GetOrderInfoMock          mLomsRepositoryMockGetOrderInfo

	funcGetOrderStatus          func(ctx context.Context, orderId int64) (s1 string, err error)
	inspectFuncGetOrderStatus   func(ctx context.Context, orderId int64)
	afterGetOrderStatusCounter  uint64
	beforeGetOrderStatusCounter uint64
	GetOrderStatusMock          mLomsRepositoryMockGetOrderStatus

	funcGetOutdatedOrders          func(ctx context.Context) (ia1 []int64, err error)
	inspectFuncGetOutdatedOrders   func(ctx context.Context)
	afterGetOutdatedOrdersCounter  uint64
	beforeGetOutdatedOrdersCounter uint64
	GetOutdatedOrdersMock          mLomsRepositoryMockGetOutdatedOrders

	funcListStocks          func(ctx context.Context, sku uint32) (sa1 []domain.Stock, err error)
	inspectFuncListStocks   func(ctx context.Context, sku uint32)
	afterListStocksCounter  uint64
	beforeListStocksCounter uint64
	ListStocksMock          mLomsRepositoryMockListStocks

	funcRunReadCommitedTransaction          func(ctx context.Context, fx func(ctxTX context.Context) error) (err error)
	inspectFuncRunReadCommitedTransaction   func(ctx context.Context, fx func(ctxTX context.Context) error)
	afterRunReadCommitedTransactionCounter  uint64
	beforeRunReadCommitedTransactionCounter uint64
	RunReadCommitedTransactionMock          mLomsRepositoryMockRunReadCommitedTransaction

	funcUpdateOrderStatus          func(ctx context.Context, orderId int64, status string) (err error)
	inspectFuncUpdateOrderStatus   func(ctx context.Context, orderId int64, status string)
	afterUpdateOrderStatusCounter  uint64
	beforeUpdateOrderStatusCounter uint64
	UpdateOrderStatusMock          mLomsRepositoryMockUpdateOrderStatus
}

// NewLomsRepositoryMock returns a mock for repository.LomsRepository
func NewLomsRepositoryMock(t minimock.Tester) *LomsRepositoryMock {
	m := &LomsRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ApplyOrderReservationsMock = mLomsRepositoryMockApplyOrderReservations{mock: m}
	m.ApplyOrderReservationsMock.callArgs = []*LomsRepositoryMockApplyOrderReservationsParams{}

	m.ClearReservationsMock = mLomsRepositoryMockClearReservations{mock: m}
	m.ClearReservationsMock.callArgs = []*LomsRepositoryMockClearReservationsParams{}

	m.CreateOrderMock = mLomsRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*LomsRepositoryMockCreateOrderParams{}

	m.CreateOrderItemsMock = mLomsRepositoryMockCreateOrderItems{mock: m}
	m.CreateOrderItemsMock.callArgs = []*LomsRepositoryMockCreateOrderItemsParams{}

	m.CreateReservationMock = mLomsRepositoryMockCreateReservation{mock: m}
	m.CreateReservationMock.callArgs = []*LomsRepositoryMockCreateReservationParams{}

	m.GetOrderInfoMock = mLomsRepositoryMockGetOrderInfo{mock: m}
	m.GetOrderInfoMock.callArgs = []*LomsRepositoryMockGetOrderInfoParams{}

	m.GetOrderStatusMock = mLomsRepositoryMockGetOrderStatus{mock: m}
	m.GetOrderStatusMock.callArgs = []*LomsRepositoryMockGetOrderStatusParams{}

	m.GetOutdatedOrdersMock = mLomsRepositoryMockGetOutdatedOrders{mock: m}
	m.GetOutdatedOrdersMock.callArgs = []*LomsRepositoryMockGetOutdatedOrdersParams{}

	m.ListStocksMock = mLomsRepositoryMockListStocks{mock: m}
	m.ListStocksMock.callArgs = []*LomsRepositoryMockListStocksParams{}

	m.RunReadCommitedTransactionMock = mLomsRepositoryMockRunReadCommitedTransaction{mock: m}
	m.RunReadCommitedTransactionMock.callArgs = []*LomsRepositoryMockRunReadCommitedTransactionParams{}

	m.UpdateOrderStatusMock = mLomsRepositoryMockUpdateOrderStatus{mock: m}
	m.UpdateOrderStatusMock.callArgs = []*LomsRepositoryMockUpdateOrderStatusParams{}

	return m
}

type mLomsRepositoryMockApplyOrderReservations struct {
	mock               *LomsRepositoryMock
	defaultExpectation *LomsRepositoryMockApplyOrderReservationsExpectation
	expectations       []*LomsRepositoryMockApplyOrderReservationsExpectation

	callArgs []*LomsRepositoryMockApplyOrderReservationsParams
	mutex    sync.RWMutex
}

// LomsRepositoryMockApplyOrderReservationsExpectation specifies expectation struct of the LomsRepository.ApplyOrderReservations
type LomsRepositoryMockApplyOrderReservationsExpectation struct {
	mock    *LomsRepositoryMock
	params  *LomsRepositoryMockApplyOrderReservationsParams
	results *LomsRepositoryMockApplyOrderReservationsResults
	Counter uint64
}

// LomsRepositoryMockApplyOrderReservationsParams contains parameters of the LomsRepository.ApplyOrderReservations
type LomsRepositoryMockApplyOrderReservationsParams struct {
	ctx     context.Context
	orderId int64
}

// LomsRepositoryMockApplyOrderReservationsResults contains results of the LomsRepository.ApplyOrderReservations
type LomsRepositoryMockApplyOrderReservationsResults struct {
	err error
}

// Expect sets up expected params for LomsRepository.ApplyOrderReservations
func (mmApplyOrderReservations *mLomsRepositoryMockApplyOrderReservations) Expect(ctx context.Context, orderId int64) *mLomsRepositoryMockApplyOrderReservations {
	if mmApplyOrderReservations.mock.funcApplyOrderReservations != nil {
		mmApplyOrderReservations.mock.t.Fatalf("LomsRepositoryMock.ApplyOrderReservations mock is already set by Set")
	}

	if mmApplyOrderReservations.defaultExpectation == nil {
		mmApplyOrderReservations.defaultExpectation = &LomsRepositoryMockApplyOrderReservationsExpectation{}
	}

	mmApplyOrderReservations.defaultExpectation.params = &LomsRepositoryMockApplyOrderReservationsParams{ctx, orderId}
	for _, e := range mmApplyOrderReservations.expectations {
		if minimock.Equal(e.params, mmApplyOrderReservations.defaultExpectation.params) {
			mmApplyOrderReservations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApplyOrderReservations.defaultExpectation.params)
		}
	}

	return mmApplyOrderReservations
}

// Inspect accepts an inspector function that has same arguments as the LomsRepository.ApplyOrderReservations
func (mmApplyOrderReservations *mLomsRepositoryMockApplyOrderReservations) Inspect(f func(ctx context.Context, orderId int64)) *mLomsRepositoryMockApplyOrderReservations {
	if mmApplyOrderReservations.mock.inspectFuncApplyOrderReservations != nil {
		mmApplyOrderReservations.mock.t.Fatalf("Inspect function is already set for LomsRepositoryMock.ApplyOrderReservations")
	}

	mmApplyOrderReservations.mock.inspectFuncApplyOrderReservations = f

	return mmApplyOrderReservations
}

// Return sets up results that will be returned by LomsRepository.ApplyOrderReservations
func (mmApplyOrderReservations *mLomsRepositoryMockApplyOrderReservations) Return(err error) *LomsRepositoryMock {
	if mmApplyOrderReservations.mock.funcApplyOrderReservations != nil {
		mmApplyOrderReservations.mock.t.Fatalf("LomsRepositoryMock.ApplyOrderReservations mock is already set by Set")
	}

	if mmApplyOrderReservations.defaultExpectation == nil {
		mmApplyOrderReservations.defaultExpectation = &LomsRepositoryMockApplyOrderReservationsExpectation{mock: mmApplyOrderReservations.mock}
	}
	mmApplyOrderReservations.defaultExpectation.results = &LomsRepositoryMockApplyOrderReservationsResults{err}
	return mmApplyOrderReservations.mock
}

// Set uses given function f to mock the LomsRepository.ApplyOrderReservations method
func (mmApplyOrderReservations *mLomsRepositoryMockApplyOrderReservations) Set(f func(ctx context.Context, orderId int64) (err error)) *LomsRepositoryMock {
	if mmApplyOrderReservations.defaultExpectation != nil {
		mmApplyOrderReservations.mock.t.Fatalf("Default expectation is already set for the LomsRepository.ApplyOrderReservations method")
	}

	if len(mmApplyOrderReservations.expectations) > 0 {
		mmApplyOrderReservations.mock.t.Fatalf("Some expectations are already set for the LomsRepository.ApplyOrderReservations method")
	}

	mmApplyOrderReservations.mock.funcApplyOrderReservations = f
	return mmApplyOrderReservations.mock
}

// When sets expectation for the LomsRepository.ApplyOrderReservations which will trigger the result defined by the following
// Then helper
func (mmApplyOrderReservations *mLomsRepositoryMockApplyOrderReservations) When(ctx context.Context, orderId int64) *LomsRepositoryMockApplyOrderReservationsExpectation {
	if mmApplyOrderReservations.mock.funcApplyOrderReservations != nil {
		mmApplyOrderReservations.mock.t.Fatalf("LomsRepositoryMock.ApplyOrderReservations mock is already set by Set")
	}

	expectation := &LomsRepositoryMockApplyOrderReservationsExpectation{
		mock:   mmApplyOrderReservations.mock,
		params: &LomsRepositoryMockApplyOrderReservationsParams{ctx, orderId},
	}
	mmApplyOrderReservations.expectations = append(mmApplyOrderReservations.expectations, expectation)
	return expectation
}

// Then sets up LomsRepository.ApplyOrderReservations return parameters for the expectation previously defined by the When method
func (e *LomsRepositoryMockApplyOrderReservationsExpectation) Then(err error) *LomsRepositoryMock {
	e.results = &LomsRepositoryMockApplyOrderReservationsResults{err}
	return e.mock
}

// ApplyOrderReservations implements repository.LomsRepository
func (mmApplyOrderReservations *LomsRepositoryMock) ApplyOrderReservations(ctx context.Context, orderId int64) (err error) {
	mm_atomic.AddUint64(&mmApplyOrderReservations.beforeApplyOrderReservationsCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyOrderReservations.afterApplyOrderReservationsCounter, 1)

	if mmApplyOrderReservations.inspectFuncApplyOrderReservations != nil {
		mmApplyOrderReservations.inspectFuncApplyOrderReservations(ctx, orderId)
	}

	mm_params := &LomsRepositoryMockApplyOrderReservationsParams{ctx, orderId}

	// Record call args
	mmApplyOrderReservations.ApplyOrderReservationsMock.mutex.Lock()
	mmApplyOrderReservations.ApplyOrderReservationsMock.callArgs = append(mmApplyOrderReservations.ApplyOrderReservationsMock.callArgs, mm_params)
	mmApplyOrderReservations.ApplyOrderReservationsMock.mutex.Unlock()

	for _, e := range mmApplyOrderReservations.ApplyOrderReservationsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmApplyOrderReservations.ApplyOrderReservationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyOrderReservations.ApplyOrderReservationsMock.defaultExpectation.Counter, 1)
		mm_want := mmApplyOrderReservations.ApplyOrderReservationsMock.defaultExpectation.params
		mm_got := LomsRepositoryMockApplyOrderReservationsParams{ctx, orderId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApplyOrderReservations.t.Errorf("LomsRepositoryMock.ApplyOrderReservations got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmApplyOrderReservations.ApplyOrderReservationsMock.defaultExpectation.results
		if mm_results == nil {
			mmApplyOrderReservations.t.Fatal("No results are set for the LomsRepositoryMock.ApplyOrderReservations")
		}
		return (*mm_results).err
	}
	if mmApplyOrderReservations.funcApplyOrderReservations != nil {
		return mmApplyOrderReservations.funcApplyOrderReservations(ctx, orderId)
	}
	mmApplyOrderReservations.t.Fatalf("Unexpected call to LomsRepositoryMock.ApplyOrderReservations. %v %v", ctx, orderId)
	return
}

// ApplyOrderReservationsAfterCounter returns a count of finished LomsRepositoryMock.ApplyOrderReservations invocations
func (mmApplyOrderReservations *LomsRepositoryMock) ApplyOrderReservationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyOrderReservations.afterApplyOrderReservationsCounter)
}

// ApplyOrderReservationsBeforeCounter returns a count of LomsRepositoryMock.ApplyOrderReservations invocations
func (mmApplyOrderReservations *LomsRepositoryMock) ApplyOrderReservationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyOrderReservations.beforeApplyOrderReservationsCounter)
}

// Calls returns a list of arguments used in each call to LomsRepositoryMock.ApplyOrderReservations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApplyOrderReservations *mLomsRepositoryMockApplyOrderReservations) Calls() []*LomsRepositoryMockApplyOrderReservationsParams {
	mmApplyOrderReservations.mutex.RLock()

	argCopy := make([]*LomsRepositoryMockApplyOrderReservationsParams, len(mmApplyOrderReservations.callArgs))
	copy(argCopy, mmApplyOrderReservations.callArgs)

	mmApplyOrderReservations.mutex.RUnlock()

	return argCopy
}

// MinimockApplyOrderReservationsDone returns true if the count of the ApplyOrderReservations invocations corresponds
// the number of defined expectations
func (m *LomsRepositoryMock) MinimockApplyOrderReservationsDone() bool {
	for _, e := range m.ApplyOrderReservationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyOrderReservationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyOrderReservationsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyOrderReservations != nil && mm_atomic.LoadUint64(&m.afterApplyOrderReservationsCounter) < 1 {
		return false
	}
	return true
}

// MinimockApplyOrderReservationsInspect logs each unmet expectation
func (m *LomsRepositoryMock) MinimockApplyOrderReservationsInspect() {
	for _, e := range m.ApplyOrderReservationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsRepositoryMock.ApplyOrderReservations with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyOrderReservationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterApplyOrderReservationsCounter) < 1 {
		if m.ApplyOrderReservationsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsRepositoryMock.ApplyOrderReservations")
		} else {
			m.t.Errorf("Expected call to LomsRepositoryMock.ApplyOrderReservations with params: %#v", *m.ApplyOrderReservationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyOrderReservations != nil && mm_atomic.LoadUint64(&m.afterApplyOrderReservationsCounter) < 1 {
		m.t.Error("Expected call to LomsRepositoryMock.ApplyOrderReservations")
	}
}

type mLomsRepositoryMockClearReservations struct {
	mock               *LomsRepositoryMock
	defaultExpectation *LomsRepositoryMockClearReservationsExpectation
	expectations       []*LomsRepositoryMockClearReservationsExpectation

	callArgs []*LomsRepositoryMockClearReservationsParams
	mutex    sync.RWMutex
}

// LomsRepositoryMockClearReservationsExpectation specifies expectation struct of the LomsRepository.ClearReservations
type LomsRepositoryMockClearReservationsExpectation struct {
	mock    *LomsRepositoryMock
	params  *LomsRepositoryMockClearReservationsParams
	results *LomsRepositoryMockClearReservationsResults
	Counter uint64
}

// LomsRepositoryMockClearReservationsParams contains parameters of the LomsRepository.ClearReservations
type LomsRepositoryMockClearReservationsParams struct {
	ctx     context.Context
	orderId int64
}

// LomsRepositoryMockClearReservationsResults contains results of the LomsRepository.ClearReservations
type LomsRepositoryMockClearReservationsResults struct {
	err error
}

// Expect sets up expected params for LomsRepository.ClearReservations
func (mmClearReservations *mLomsRepositoryMockClearReservations) Expect(ctx context.Context, orderId int64) *mLomsRepositoryMockClearReservations {
	if mmClearReservations.mock.funcClearReservations != nil {
		mmClearReservations.mock.t.Fatalf("LomsRepositoryMock.ClearReservations mock is already set by Set")
	}

	if mmClearReservations.defaultExpectation == nil {
		mmClearReservations.defaultExpectation = &LomsRepositoryMockClearReservationsExpectation{}
	}

	mmClearReservations.defaultExpectation.params = &LomsRepositoryMockClearReservationsParams{ctx, orderId}
	for _, e := range mmClearReservations.expectations {
		if minimock.Equal(e.params, mmClearReservations.defaultExpectation.params) {
			mmClearReservations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearReservations.defaultExpectation.params)
		}
	}

	return mmClearReservations
}

// Inspect accepts an inspector function that has same arguments as the LomsRepository.ClearReservations
func (mmClearReservations *mLomsRepositoryMockClearReservations) Inspect(f func(ctx context.Context, orderId int64)) *mLomsRepositoryMockClearReservations {
	if mmClearReservations.mock.inspectFuncClearReservations != nil {
		mmClearReservations.mock.t.Fatalf("Inspect function is already set for LomsRepositoryMock.ClearReservations")
	}

	mmClearReservations.mock.inspectFuncClearReservations = f

	return mmClearReservations
}

// Return sets up results that will be returned by LomsRepository.ClearReservations
func (mmClearReservations *mLomsRepositoryMockClearReservations) Return(err error) *LomsRepositoryMock {
	if mmClearReservations.mock.funcClearReservations != nil {
		mmClearReservations.mock.t.Fatalf("LomsRepositoryMock.ClearReservations mock is already set by Set")
	}

	if mmClearReservations.defaultExpectation == nil {
		mmClearReservations.defaultExpectation = &LomsRepositoryMockClearReservationsExpectation{mock: mmClearReservations.mock}
	}
	mmClearReservations.defaultExpectation.results = &LomsRepositoryMockClearReservationsResults{err}
	return mmClearReservations.mock
}

// Set uses given function f to mock the LomsRepository.ClearReservations method
func (mmClearReservations *mLomsRepositoryMockClearReservations) Set(f func(ctx context.Context, orderId int64) (err error)) *LomsRepositoryMock {
	if mmClearReservations.defaultExpectation != nil {
		mmClearReservations.mock.t.Fatalf("Default expectation is already set for the LomsRepository.ClearReservations method")
	}

	if len(mmClearReservations.expectations) > 0 {
		mmClearReservations.mock.t.Fatalf("Some expectations are already set for the LomsRepository.ClearReservations method")
	}

	mmClearReservations.mock.funcClearReservations = f
	return mmClearReservations.mock
}

// When sets expectation for the LomsRepository.ClearReservations which will trigger the result defined by the following
// Then helper
func (mmClearReservations *mLomsRepositoryMockClearReservations) When(ctx context.Context, orderId int64) *LomsRepositoryMockClearReservationsExpectation {
	if mmClearReservations.mock.funcClearReservations != nil {
		mmClearReservations.mock.t.Fatalf("LomsRepositoryMock.ClearReservations mock is already set by Set")
	}

	expectation := &LomsRepositoryMockClearReservationsExpectation{
		mock:   mmClearReservations.mock,
		params: &LomsRepositoryMockClearReservationsParams{ctx, orderId},
	}
	mmClearReservations.expectations = append(mmClearReservations.expectations, expectation)
	return expectation
}

// Then sets up LomsRepository.ClearReservations return parameters for the expectation previously defined by the When method
func (e *LomsRepositoryMockClearReservationsExpectation) Then(err error) *LomsRepositoryMock {
	e.results = &LomsRepositoryMockClearReservationsResults{err}
	return e.mock
}

// ClearReservations implements repository.LomsRepository
func (mmClearReservations *LomsRepositoryMock) ClearReservations(ctx context.Context, orderId int64) (err error) {
	mm_atomic.AddUint64(&mmClearReservations.beforeClearReservationsCounter, 1)
	defer mm_atomic.AddUint64(&mmClearReservations.afterClearReservationsCounter, 1)

	if mmClearReservations.inspectFuncClearReservations != nil {
		mmClearReservations.inspectFuncClearReservations(ctx, orderId)
	}

	mm_params := &LomsRepositoryMockClearReservationsParams{ctx, orderId}

	// Record call args
	mmClearReservations.ClearReservationsMock.mutex.Lock()
	mmClearReservations.ClearReservationsMock.callArgs = append(mmClearReservations.ClearReservationsMock.callArgs, mm_params)
	mmClearReservations.ClearReservationsMock.mutex.Unlock()

	for _, e := range mmClearReservations.ClearReservationsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearReservations.ClearReservationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearReservations.ClearReservationsMock.defaultExpectation.Counter, 1)
		mm_want := mmClearReservations.ClearReservationsMock.defaultExpectation.params
		mm_got := LomsRepositoryMockClearReservationsParams{ctx, orderId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearReservations.t.Errorf("LomsRepositoryMock.ClearReservations got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearReservations.ClearReservationsMock.defaultExpectation.results
		if mm_results == nil {
			mmClearReservations.t.Fatal("No results are set for the LomsRepositoryMock.ClearReservations")
		}
		return (*mm_results).err
	}
	if mmClearReservations.funcClearReservations != nil {
		return mmClearReservations.funcClearReservations(ctx, orderId)
	}
	mmClearReservations.t.Fatalf("Unexpected call to LomsRepositoryMock.ClearReservations. %v %v", ctx, orderId)
	return
}

// ClearReservationsAfterCounter returns a count of finished LomsRepositoryMock.ClearReservations invocations
func (mmClearReservations *LomsRepositoryMock) ClearReservationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearReservations.afterClearReservationsCounter)
}

// ClearReservationsBeforeCounter returns a count of LomsRepositoryMock.ClearReservations invocations
func (mmClearReservations *LomsRepositoryMock) ClearReservationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearReservations.beforeClearReservationsCounter)
}

// Calls returns a list of arguments used in each call to LomsRepositoryMock.ClearReservations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearReservations *mLomsRepositoryMockClearReservations) Calls() []*LomsRepositoryMockClearReservationsParams {
	mmClearReservations.mutex.RLock()

	argCopy := make([]*LomsRepositoryMockClearReservationsParams, len(mmClearReservations.callArgs))
	copy(argCopy, mmClearReservations.callArgs)

	mmClearReservations.mutex.RUnlock()

	return argCopy
}

// MinimockClearReservationsDone returns true if the count of the ClearReservations invocations corresponds
// the number of defined expectations
func (m *LomsRepositoryMock) MinimockClearReservationsDone() bool {
	for _, e := range m.ClearReservationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClearReservationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClearReservationsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearReservations != nil && mm_atomic.LoadUint64(&m.afterClearReservationsCounter) < 1 {
		return false
	}
	return true
}

// MinimockClearReservationsInspect logs each unmet expectation
func (m *LomsRepositoryMock) MinimockClearReservationsInspect() {
	for _, e := range m.ClearReservationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsRepositoryMock.ClearReservations with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClearReservationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClearReservationsCounter) < 1 {
		if m.ClearReservationsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsRepositoryMock.ClearReservations")
		} else {
			m.t.Errorf("Expected call to LomsRepositoryMock.ClearReservations with params: %#v", *m.ClearReservationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearReservations != nil && mm_atomic.LoadUint64(&m.afterClearReservationsCounter) < 1 {
		m.t.Error("Expected call to LomsRepositoryMock.ClearReservations")
	}
}

type mLomsRepositoryMockCreateOrder struct {
	mock               *LomsRepositoryMock
	defaultExpectation *LomsRepositoryMockCreateOrderExpectation
	expectations       []*LomsRepositoryMockCreateOrderExpectation

	callArgs []*LomsRepositoryMockCreateOrderParams
	mutex    sync.RWMutex
}

// LomsRepositoryMockCreateOrderExpectation specifies expectation struct of the LomsRepository.CreateOrder
type LomsRepositoryMockCreateOrderExpectation struct {
	mock    *LomsRepositoryMock
	params  *LomsRepositoryMockCreateOrderParams
	results *LomsRepositoryMockCreateOrderResults
	Counter uint64
}

// LomsRepositoryMockCreateOrderParams contains parameters of the LomsRepository.CreateOrder
type LomsRepositoryMockCreateOrderParams struct {
	ctx    context.Context
	userId domain.UserId
}

// LomsRepositoryMockCreateOrderResults contains results of the LomsRepository.CreateOrder
type LomsRepositoryMockCreateOrderResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for LomsRepository.CreateOrder
func (mmCreateOrder *mLomsRepositoryMockCreateOrder) Expect(ctx context.Context, userId domain.UserId) *mLomsRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("LomsRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &LomsRepositoryMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &LomsRepositoryMockCreateOrderParams{ctx, userId}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the LomsRepository.CreateOrder
func (mmCreateOrder *mLomsRepositoryMockCreateOrder) Inspect(f func(ctx context.Context, userId domain.UserId)) *mLomsRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for LomsRepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by LomsRepository.CreateOrder
func (mmCreateOrder *mLomsRepositoryMockCreateOrder) Return(i1 int64, err error) *LomsRepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("LomsRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &LomsRepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &LomsRepositoryMockCreateOrderResults{i1, err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the LomsRepository.CreateOrder method
func (mmCreateOrder *mLomsRepositoryMockCreateOrder) Set(f func(ctx context.Context, userId domain.UserId) (i1 int64, err error)) *LomsRepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the LomsRepository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the LomsRepository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the LomsRepository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mLomsRepositoryMockCreateOrder) When(ctx context.Context, userId domain.UserId) *LomsRepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("LomsRepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &LomsRepositoryMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &LomsRepositoryMockCreateOrderParams{ctx, userId},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up LomsRepository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *LomsRepositoryMockCreateOrderExpectation) Then(i1 int64, err error) *LomsRepositoryMock {
	e.results = &LomsRepositoryMockCreateOrderResults{i1, err}
	return e.mock
}

// CreateOrder implements repository.LomsRepository
func (mmCreateOrder *LomsRepositoryMock) CreateOrder(ctx context.Context, userId domain.UserId) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, userId)
	}

	mm_params := &LomsRepositoryMockCreateOrderParams{ctx, userId}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := LomsRepositoryMockCreateOrderParams{ctx, userId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("LomsRepositoryMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the LomsRepositoryMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, userId)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to LomsRepositoryMock.CreateOrder. %v %v", ctx, userId)
	return
}

// CreateOrderAfterCounter returns a count of finished LomsRepositoryMock.CreateOrder invocations
func (mmCreateOrder *LomsRepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of LomsRepositoryMock.CreateOrder invocations
func (mmCreateOrder *LomsRepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to LomsRepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mLomsRepositoryMockCreateOrder) Calls() []*LomsRepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*LomsRepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *LomsRepositoryMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *LomsRepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsRepositoryMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsRepositoryMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to LomsRepositoryMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to LomsRepositoryMock.CreateOrder")
	}
}

type mLomsRepositoryMockCreateOrderItems struct {
	mock               *LomsRepositoryMock
	defaultExpectation *LomsRepositoryMockCreateOrderItemsExpectation
	expectations       []*LomsRepositoryMockCreateOrderItemsExpectation

	callArgs []*LomsRepositoryMockCreateOrderItemsParams
	mutex    sync.RWMutex
}

// LomsRepositoryMockCreateOrderItemsExpectation specifies expectation struct of the LomsRepository.CreateOrderItems
type LomsRepositoryMockCreateOrderItemsExpectation struct {
	mock    *LomsRepositoryMock
	params  *LomsRepositoryMockCreateOrderItemsParams
	results *LomsRepositoryMockCreateOrderItemsResults
	Counter uint64
}

// LomsRepositoryMockCreateOrderItemsParams contains parameters of the LomsRepository.CreateOrderItems
type LomsRepositoryMockCreateOrderItemsParams struct {
	ctx     context.Context
	orderId int64
	items   []domain.OrderItem
}

// LomsRepositoryMockCreateOrderItemsResults contains results of the LomsRepository.CreateOrderItems
type LomsRepositoryMockCreateOrderItemsResults struct {
	err error
}

// Expect sets up expected params for LomsRepository.CreateOrderItems
func (mmCreateOrderItems *mLomsRepositoryMockCreateOrderItems) Expect(ctx context.Context, orderId int64, items []domain.OrderItem) *mLomsRepositoryMockCreateOrderItems {
	if mmCreateOrderItems.mock.funcCreateOrderItems != nil {
		mmCreateOrderItems.mock.t.Fatalf("LomsRepositoryMock.CreateOrderItems mock is already set by Set")
	}

	if mmCreateOrderItems.defaultExpectation == nil {
		mmCreateOrderItems.defaultExpectation = &LomsRepositoryMockCreateOrderItemsExpectation{}
	}

	mmCreateOrderItems.defaultExpectation.params = &LomsRepositoryMockCreateOrderItemsParams{ctx, orderId, items}
	for _, e := range mmCreateOrderItems.expectations {
		if minimock.Equal(e.params, mmCreateOrderItems.defaultExpectation.params) {
			mmCreateOrderItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrderItems.defaultExpectation.params)
		}
	}

	return mmCreateOrderItems
}

// Inspect accepts an inspector function that has same arguments as the LomsRepository.CreateOrderItems
func (mmCreateOrderItems *mLomsRepositoryMockCreateOrderItems) Inspect(f func(ctx context.Context, orderId int64, items []domain.OrderItem)) *mLomsRepositoryMockCreateOrderItems {
	if mmCreateOrderItems.mock.inspectFuncCreateOrderItems != nil {
		mmCreateOrderItems.mock.t.Fatalf("Inspect function is already set for LomsRepositoryMock.CreateOrderItems")
	}

	mmCreateOrderItems.mock.inspectFuncCreateOrderItems = f

	return mmCreateOrderItems
}

// Return sets up results that will be returned by LomsRepository.CreateOrderItems
func (mmCreateOrderItems *mLomsRepositoryMockCreateOrderItems) Return(err error) *LomsRepositoryMock {
	if mmCreateOrderItems.mock.funcCreateOrderItems != nil {
		mmCreateOrderItems.mock.t.Fatalf("LomsRepositoryMock.CreateOrderItems mock is already set by Set")
	}

	if mmCreateOrderItems.defaultExpectation == nil {
		mmCreateOrderItems.defaultExpectation = &LomsRepositoryMockCreateOrderItemsExpectation{mock: mmCreateOrderItems.mock}
	}
	mmCreateOrderItems.defaultExpectation.results = &LomsRepositoryMockCreateOrderItemsResults{err}
	return mmCreateOrderItems.mock
}

// Set uses given function f to mock the LomsRepository.CreateOrderItems method
func (mmCreateOrderItems *mLomsRepositoryMockCreateOrderItems) Set(f func(ctx context.Context, orderId int64, items []domain.OrderItem) (err error)) *LomsRepositoryMock {
	if mmCreateOrderItems.defaultExpectation != nil {
		mmCreateOrderItems.mock.t.Fatalf("Default expectation is already set for the LomsRepository.CreateOrderItems method")
	}

	if len(mmCreateOrderItems.expectations) > 0 {
		mmCreateOrderItems.mock.t.Fatalf("Some expectations are already set for the LomsRepository.CreateOrderItems method")
	}

	mmCreateOrderItems.mock.funcCreateOrderItems = f
	return mmCreateOrderItems.mock
}

// When sets expectation for the LomsRepository.CreateOrderItems which will trigger the result defined by the following
// Then helper
func (mmCreateOrderItems *mLomsRepositoryMockCreateOrderItems) When(ctx context.Context, orderId int64, items []domain.OrderItem) *LomsRepositoryMockCreateOrderItemsExpectation {
	if mmCreateOrderItems.mock.funcCreateOrderItems != nil {
		mmCreateOrderItems.mock.t.Fatalf("LomsRepositoryMock.CreateOrderItems mock is already set by Set")
	}

	expectation := &LomsRepositoryMockCreateOrderItemsExpectation{
		mock:   mmCreateOrderItems.mock,
		params: &LomsRepositoryMockCreateOrderItemsParams{ctx, orderId, items},
	}
	mmCreateOrderItems.expectations = append(mmCreateOrderItems.expectations, expectation)
	return expectation
}

// Then sets up LomsRepository.CreateOrderItems return parameters for the expectation previously defined by the When method
func (e *LomsRepositoryMockCreateOrderItemsExpectation) Then(err error) *LomsRepositoryMock {
	e.results = &LomsRepositoryMockCreateOrderItemsResults{err}
	return e.mock
}

// CreateOrderItems implements repository.LomsRepository
func (mmCreateOrderItems *LomsRepositoryMock) CreateOrderItems(ctx context.Context, orderId int64, items []domain.OrderItem) (err error) {
	mm_atomic.AddUint64(&mmCreateOrderItems.beforeCreateOrderItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrderItems.afterCreateOrderItemsCounter, 1)

	if mmCreateOrderItems.inspectFuncCreateOrderItems != nil {
		mmCreateOrderItems.inspectFuncCreateOrderItems(ctx, orderId, items)
	}

	mm_params := &LomsRepositoryMockCreateOrderItemsParams{ctx, orderId, items}

	// Record call args
	mmCreateOrderItems.CreateOrderItemsMock.mutex.Lock()
	mmCreateOrderItems.CreateOrderItemsMock.callArgs = append(mmCreateOrderItems.CreateOrderItemsMock.callArgs, mm_params)
	mmCreateOrderItems.CreateOrderItemsMock.mutex.Unlock()

	for _, e := range mmCreateOrderItems.CreateOrderItemsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation.params
		mm_got := LomsRepositoryMockCreateOrderItemsParams{ctx, orderId, items}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrderItems.t.Errorf("LomsRepositoryMock.CreateOrderItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrderItems.CreateOrderItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrderItems.t.Fatal("No results are set for the LomsRepositoryMock.CreateOrderItems")
		}
		return (*mm_results).err
	}
	if mmCreateOrderItems.funcCreateOrderItems != nil {
		return mmCreateOrderItems.funcCreateOrderItems(ctx, orderId, items)
	}
	mmCreateOrderItems.t.Fatalf("Unexpected call to LomsRepositoryMock.CreateOrderItems. %v %v %v", ctx, orderId, items)
	return
}

// CreateOrderItemsAfterCounter returns a count of finished LomsRepositoryMock.CreateOrderItems invocations
func (mmCreateOrderItems *LomsRepositoryMock) CreateOrderItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrderItems.afterCreateOrderItemsCounter)
}

// CreateOrderItemsBeforeCounter returns a count of LomsRepositoryMock.CreateOrderItems invocations
func (mmCreateOrderItems *LomsRepositoryMock) CreateOrderItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrderItems.beforeCreateOrderItemsCounter)
}

// Calls returns a list of arguments used in each call to LomsRepositoryMock.CreateOrderItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrderItems *mLomsRepositoryMockCreateOrderItems) Calls() []*LomsRepositoryMockCreateOrderItemsParams {
	mmCreateOrderItems.mutex.RLock()

	argCopy := make([]*LomsRepositoryMockCreateOrderItemsParams, len(mmCreateOrderItems.callArgs))
	copy(argCopy, mmCreateOrderItems.callArgs)

	mmCreateOrderItems.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderItemsDone returns true if the count of the CreateOrderItems invocations corresponds
// the number of defined expectations
func (m *LomsRepositoryMock) MinimockCreateOrderItemsDone() bool {
	for _, e := range m.CreateOrderItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderItemsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrderItems != nil && mm_atomic.LoadUint64(&m.afterCreateOrderItemsCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderItemsInspect logs each unmet expectation
func (m *LomsRepositoryMock) MinimockCreateOrderItemsInspect() {
	for _, e := range m.CreateOrderItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsRepositoryMock.CreateOrderItems with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderItemsCounter) < 1 {
		if m.CreateOrderItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsRepositoryMock.CreateOrderItems")
		} else {
			m.t.Errorf("Expected call to LomsRepositoryMock.CreateOrderItems with params: %#v", *m.CreateOrderItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrderItems != nil && mm_atomic.LoadUint64(&m.afterCreateOrderItemsCounter) < 1 {
		m.t.Error("Expected call to LomsRepositoryMock.CreateOrderItems")
	}
}

type mLomsRepositoryMockCreateReservation struct {
	mock               *LomsRepositoryMock
	defaultExpectation *LomsRepositoryMockCreateReservationExpectation
	expectations       []*LomsRepositoryMockCreateReservationExpectation

	callArgs []*LomsRepositoryMockCreateReservationParams
	mutex    sync.RWMutex
}

// LomsRepositoryMockCreateReservationExpectation specifies expectation struct of the LomsRepository.CreateReservation
type LomsRepositoryMockCreateReservationExpectation struct {
	mock    *LomsRepositoryMock
	params  *LomsRepositoryMockCreateReservationParams
	results *LomsRepositoryMockCreateReservationResults
	Counter uint64
}

// LomsRepositoryMockCreateReservationParams contains parameters of the LomsRepository.CreateReservation
type LomsRepositoryMockCreateReservationParams struct {
	ctx          context.Context
	reservations []domain.Reservation
}

// LomsRepositoryMockCreateReservationResults contains results of the LomsRepository.CreateReservation
type LomsRepositoryMockCreateReservationResults struct {
	err error
}

// Expect sets up expected params for LomsRepository.CreateReservation
func (mmCreateReservation *mLomsRepositoryMockCreateReservation) Expect(ctx context.Context, reservations []domain.Reservation) *mLomsRepositoryMockCreateReservation {
	if mmCreateReservation.mock.funcCreateReservation != nil {
		mmCreateReservation.mock.t.Fatalf("LomsRepositoryMock.CreateReservation mock is already set by Set")
	}

	if mmCreateReservation.defaultExpectation == nil {
		mmCreateReservation.defaultExpectation = &LomsRepositoryMockCreateReservationExpectation{}
	}

	mmCreateReservation.defaultExpectation.params = &LomsRepositoryMockCreateReservationParams{ctx, reservations}
	for _, e := range mmCreateReservation.expectations {
		if minimock.Equal(e.params, mmCreateReservation.defaultExpectation.params) {
			mmCreateReservation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateReservation.defaultExpectation.params)
		}
	}

	return mmCreateReservation
}

// Inspect accepts an inspector function that has same arguments as the LomsRepository.CreateReservation
func (mmCreateReservation *mLomsRepositoryMockCreateReservation) Inspect(f func(ctx context.Context, reservations []domain.Reservation)) *mLomsRepositoryMockCreateReservation {
	if mmCreateReservation.mock.inspectFuncCreateReservation != nil {
		mmCreateReservation.mock.t.Fatalf("Inspect function is already set for LomsRepositoryMock.CreateReservation")
	}

	mmCreateReservation.mock.inspectFuncCreateReservation = f

	return mmCreateReservation
}

// Return sets up results that will be returned by LomsRepository.CreateReservation
func (mmCreateReservation *mLomsRepositoryMockCreateReservation) Return(err error) *LomsRepositoryMock {
	if mmCreateReservation.mock.funcCreateReservation != nil {
		mmCreateReservation.mock.t.Fatalf("LomsRepositoryMock.CreateReservation mock is already set by Set")
	}

	if mmCreateReservation.defaultExpectation == nil {
		mmCreateReservation.defaultExpectation = &LomsRepositoryMockCreateReservationExpectation{mock: mmCreateReservation.mock}
	}
	mmCreateReservation.defaultExpectation.results = &LomsRepositoryMockCreateReservationResults{err}
	return mmCreateReservation.mock
}

// Set uses given function f to mock the LomsRepository.CreateReservation method
func (mmCreateReservation *mLomsRepositoryMockCreateReservation) Set(f func(ctx context.Context, reservations []domain.Reservation) (err error)) *LomsRepositoryMock {
	if mmCreateReservation.defaultExpectation != nil {
		mmCreateReservation.mock.t.Fatalf("Default expectation is already set for the LomsRepository.CreateReservation method")
	}

	if len(mmCreateReservation.expectations) > 0 {
		mmCreateReservation.mock.t.Fatalf("Some expectations are already set for the LomsRepository.CreateReservation method")
	}

	mmCreateReservation.mock.funcCreateReservation = f
	return mmCreateReservation.mock
}

// When sets expectation for the LomsRepository.CreateReservation which will trigger the result defined by the following
// Then helper
func (mmCreateReservation *mLomsRepositoryMockCreateReservation) When(ctx context.Context, reservations []domain.Reservation) *LomsRepositoryMockCreateReservationExpectation {
	if mmCreateReservation.mock.funcCreateReservation != nil {
		mmCreateReservation.mock.t.Fatalf("LomsRepositoryMock.CreateReservation mock is already set by Set")
	}

	expectation := &LomsRepositoryMockCreateReservationExpectation{
		mock:   mmCreateReservation.mock,
		params: &LomsRepositoryMockCreateReservationParams{ctx, reservations},
	}
	mmCreateReservation.expectations = append(mmCreateReservation.expectations, expectation)
	return expectation
}

// Then sets up LomsRepository.CreateReservation return parameters for the expectation previously defined by the When method
func (e *LomsRepositoryMockCreateReservationExpectation) Then(err error) *LomsRepositoryMock {
	e.results = &LomsRepositoryMockCreateReservationResults{err}
	return e.mock
}

// CreateReservation implements repository.LomsRepository
func (mmCreateReservation *LomsRepositoryMock) CreateReservation(ctx context.Context, reservations []domain.Reservation) (err error) {
	mm_atomic.AddUint64(&mmCreateReservation.beforeCreateReservationCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateReservation.afterCreateReservationCounter, 1)

	if mmCreateReservation.inspectFuncCreateReservation != nil {
		mmCreateReservation.inspectFuncCreateReservation(ctx, reservations)
	}

	mm_params := &LomsRepositoryMockCreateReservationParams{ctx, reservations}

	// Record call args
	mmCreateReservation.CreateReservationMock.mutex.Lock()
	mmCreateReservation.CreateReservationMock.callArgs = append(mmCreateReservation.CreateReservationMock.callArgs, mm_params)
	mmCreateReservation.CreateReservationMock.mutex.Unlock()

	for _, e := range mmCreateReservation.CreateReservationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateReservation.CreateReservationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateReservation.CreateReservationMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateReservation.CreateReservationMock.defaultExpectation.params
		mm_got := LomsRepositoryMockCreateReservationParams{ctx, reservations}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateReservation.t.Errorf("LomsRepositoryMock.CreateReservation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateReservation.CreateReservationMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateReservation.t.Fatal("No results are set for the LomsRepositoryMock.CreateReservation")
		}
		return (*mm_results).err
	}
	if mmCreateReservation.funcCreateReservation != nil {
		return mmCreateReservation.funcCreateReservation(ctx, reservations)
	}
	mmCreateReservation.t.Fatalf("Unexpected call to LomsRepositoryMock.CreateReservation. %v %v", ctx, reservations)
	return
}

// CreateReservationAfterCounter returns a count of finished LomsRepositoryMock.CreateReservation invocations
func (mmCreateReservation *LomsRepositoryMock) CreateReservationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReservation.afterCreateReservationCounter)
}

// CreateReservationBeforeCounter returns a count of LomsRepositoryMock.CreateReservation invocations
func (mmCreateReservation *LomsRepositoryMock) CreateReservationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReservation.beforeCreateReservationCounter)
}

// Calls returns a list of arguments used in each call to LomsRepositoryMock.CreateReservation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateReservation *mLomsRepositoryMockCreateReservation) Calls() []*LomsRepositoryMockCreateReservationParams {
	mmCreateReservation.mutex.RLock()

	argCopy := make([]*LomsRepositoryMockCreateReservationParams, len(mmCreateReservation.callArgs))
	copy(argCopy, mmCreateReservation.callArgs)

	mmCreateReservation.mutex.RUnlock()

	return argCopy
}

// MinimockCreateReservationDone returns true if the count of the CreateReservation invocations corresponds
// the number of defined expectations
func (m *LomsRepositoryMock) MinimockCreateReservationDone() bool {
	for _, e := range m.CreateReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReservationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateReservationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReservation != nil && mm_atomic.LoadUint64(&m.afterCreateReservationCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateReservationInspect logs each unmet expectation
func (m *LomsRepositoryMock) MinimockCreateReservationInspect() {
	for _, e := range m.CreateReservationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsRepositoryMock.CreateReservation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReservationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateReservationCounter) < 1 {
		if m.CreateReservationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsRepositoryMock.CreateReservation")
		} else {
			m.t.Errorf("Expected call to LomsRepositoryMock.CreateReservation with params: %#v", *m.CreateReservationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReservation != nil && mm_atomic.LoadUint64(&m.afterCreateReservationCounter) < 1 {
		m.t.Error("Expected call to LomsRepositoryMock.CreateReservation")
	}
}

type mLomsRepositoryMockGetOrderInfo struct {
	mock               *LomsRepositoryMock
	defaultExpectation *LomsRepositoryMockGetOrderInfoExpectation
	expectations       []*LomsRepositoryMockGetOrderInfoExpectation

	callArgs []*LomsRepositoryMockGetOrderInfoParams
	mutex    sync.RWMutex
}

// LomsRepositoryMockGetOrderInfoExpectation specifies expectation struct of the LomsRepository.GetOrderInfo
type LomsRepositoryMockGetOrderInfoExpectation struct {
	mock    *LomsRepositoryMock
	params  *LomsRepositoryMockGetOrderInfoParams
	results *LomsRepositoryMockGetOrderInfoResults
	Counter uint64
}

// LomsRepositoryMockGetOrderInfoParams contains parameters of the LomsRepository.GetOrderInfo
type LomsRepositoryMockGetOrderInfoParams struct {
	ctx     context.Context
	orderId int64
}

// LomsRepositoryMockGetOrderInfoResults contains results of the LomsRepository.GetOrderInfo
type LomsRepositoryMockGetOrderInfoResults struct {
	op1 *domain.OrderInfo
	err error
}

// Expect sets up expected params for LomsRepository.GetOrderInfo
func (mmGetOrderInfo *mLomsRepositoryMockGetOrderInfo) Expect(ctx context.Context, orderId int64) *mLomsRepositoryMockGetOrderInfo {
	if mmGetOrderInfo.mock.funcGetOrderInfo != nil {
		mmGetOrderInfo.mock.t.Fatalf("LomsRepositoryMock.GetOrderInfo mock is already set by Set")
	}

	if mmGetOrderInfo.defaultExpectation == nil {
		mmGetOrderInfo.defaultExpectation = &LomsRepositoryMockGetOrderInfoExpectation{}
	}

	mmGetOrderInfo.defaultExpectation.params = &LomsRepositoryMockGetOrderInfoParams{ctx, orderId}
	for _, e := range mmGetOrderInfo.expectations {
		if minimock.Equal(e.params, mmGetOrderInfo.defaultExpectation.params) {
			mmGetOrderInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderInfo.defaultExpectation.params)
		}
	}

	return mmGetOrderInfo
}

// Inspect accepts an inspector function that has same arguments as the LomsRepository.GetOrderInfo
func (mmGetOrderInfo *mLomsRepositoryMockGetOrderInfo) Inspect(f func(ctx context.Context, orderId int64)) *mLomsRepositoryMockGetOrderInfo {
	if mmGetOrderInfo.mock.inspectFuncGetOrderInfo != nil {
		mmGetOrderInfo.mock.t.Fatalf("Inspect function is already set for LomsRepositoryMock.GetOrderInfo")
	}

	mmGetOrderInfo.mock.inspectFuncGetOrderInfo = f

	return mmGetOrderInfo
}

// Return sets up results that will be returned by LomsRepository.GetOrderInfo
func (mmGetOrderInfo *mLomsRepositoryMockGetOrderInfo) Return(op1 *domain.OrderInfo, err error) *LomsRepositoryMock {
	if mmGetOrderInfo.mock.funcGetOrderInfo != nil {
		mmGetOrderInfo.mock.t.Fatalf("LomsRepositoryMock.GetOrderInfo mock is already set by Set")
	}

	if mmGetOrderInfo.defaultExpectation == nil {
		mmGetOrderInfo.defaultExpectation = &LomsRepositoryMockGetOrderInfoExpectation{mock: mmGetOrderInfo.mock}
	}
	mmGetOrderInfo.defaultExpectation.results = &LomsRepositoryMockGetOrderInfoResults{op1, err}
	return mmGetOrderInfo.mock
}

// Set uses given function f to mock the LomsRepository.GetOrderInfo method
func (mmGetOrderInfo *mLomsRepositoryMockGetOrderInfo) Set(f func(ctx context.Context, orderId int64) (op1 *domain.OrderInfo, err error)) *LomsRepositoryMock {
	if mmGetOrderInfo.defaultExpectation != nil {
		mmGetOrderInfo.mock.t.Fatalf("Default expectation is already set for the LomsRepository.GetOrderInfo method")
	}

	if len(mmGetOrderInfo.expectations) > 0 {
		mmGetOrderInfo.mock.t.Fatalf("Some expectations are already set for the LomsRepository.GetOrderInfo method")
	}

	mmGetOrderInfo.mock.funcGetOrderInfo = f
	return mmGetOrderInfo.mock
}

// When sets expectation for the LomsRepository.GetOrderInfo which will trigger the result defined by the following
// Then helper
func (mmGetOrderInfo *mLomsRepositoryMockGetOrderInfo) When(ctx context.Context, orderId int64) *LomsRepositoryMockGetOrderInfoExpectation {
	if mmGetOrderInfo.mock.funcGetOrderInfo != nil {
		mmGetOrderInfo.mock.t.Fatalf("LomsRepositoryMock.GetOrderInfo mock is already set by Set")
	}

	expectation := &LomsRepositoryMockGetOrderInfoExpectation{
		mock:   mmGetOrderInfo.mock,
		params: &LomsRepositoryMockGetOrderInfoParams{ctx, orderId},
	}
	mmGetOrderInfo.expectations = append(mmGetOrderInfo.expectations, expectation)
	return expectation
}

// Then sets up LomsRepository.GetOrderInfo return parameters for the expectation previously defined by the When method
func (e *LomsRepositoryMockGetOrderInfoExpectation) Then(op1 *domain.OrderInfo, err error) *LomsRepositoryMock {
	e.results = &LomsRepositoryMockGetOrderInfoResults{op1, err}
	return e.mock
}

// GetOrderInfo implements repository.LomsRepository
func (mmGetOrderInfo *LomsRepositoryMock) GetOrderInfo(ctx context.Context, orderId int64) (op1 *domain.OrderInfo, err error) {
	mm_atomic.AddUint64(&mmGetOrderInfo.beforeGetOrderInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderInfo.afterGetOrderInfoCounter, 1)

	if mmGetOrderInfo.inspectFuncGetOrderInfo != nil {
		mmGetOrderInfo.inspectFuncGetOrderInfo(ctx, orderId)
	}

	mm_params := &LomsRepositoryMockGetOrderInfoParams{ctx, orderId}

	// Record call args
	mmGetOrderInfo.GetOrderInfoMock.mutex.Lock()
	mmGetOrderInfo.GetOrderInfoMock.callArgs = append(mmGetOrderInfo.GetOrderInfoMock.callArgs, mm_params)
	mmGetOrderInfo.GetOrderInfoMock.mutex.Unlock()

	for _, e := range mmGetOrderInfo.GetOrderInfoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrderInfo.GetOrderInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderInfo.GetOrderInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderInfo.GetOrderInfoMock.defaultExpectation.params
		mm_got := LomsRepositoryMockGetOrderInfoParams{ctx, orderId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderInfo.t.Errorf("LomsRepositoryMock.GetOrderInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderInfo.GetOrderInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderInfo.t.Fatal("No results are set for the LomsRepositoryMock.GetOrderInfo")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrderInfo.funcGetOrderInfo != nil {
		return mmGetOrderInfo.funcGetOrderInfo(ctx, orderId)
	}
	mmGetOrderInfo.t.Fatalf("Unexpected call to LomsRepositoryMock.GetOrderInfo. %v %v", ctx, orderId)
	return
}

// GetOrderInfoAfterCounter returns a count of finished LomsRepositoryMock.GetOrderInfo invocations
func (mmGetOrderInfo *LomsRepositoryMock) GetOrderInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderInfo.afterGetOrderInfoCounter)
}

// GetOrderInfoBeforeCounter returns a count of LomsRepositoryMock.GetOrderInfo invocations
func (mmGetOrderInfo *LomsRepositoryMock) GetOrderInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderInfo.beforeGetOrderInfoCounter)
}

// Calls returns a list of arguments used in each call to LomsRepositoryMock.GetOrderInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderInfo *mLomsRepositoryMockGetOrderInfo) Calls() []*LomsRepositoryMockGetOrderInfoParams {
	mmGetOrderInfo.mutex.RLock()

	argCopy := make([]*LomsRepositoryMockGetOrderInfoParams, len(mmGetOrderInfo.callArgs))
	copy(argCopy, mmGetOrderInfo.callArgs)

	mmGetOrderInfo.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderInfoDone returns true if the count of the GetOrderInfo invocations corresponds
// the number of defined expectations
func (m *LomsRepositoryMock) MinimockGetOrderInfoDone() bool {
	for _, e := range m.GetOrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderInfo != nil && mm_atomic.LoadUint64(&m.afterGetOrderInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderInfoInspect logs each unmet expectation
func (m *LomsRepositoryMock) MinimockGetOrderInfoInspect() {
	for _, e := range m.GetOrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsRepositoryMock.GetOrderInfo with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderInfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderInfoCounter) < 1 {
		if m.GetOrderInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsRepositoryMock.GetOrderInfo")
		} else {
			m.t.Errorf("Expected call to LomsRepositoryMock.GetOrderInfo with params: %#v", *m.GetOrderInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderInfo != nil && mm_atomic.LoadUint64(&m.afterGetOrderInfoCounter) < 1 {
		m.t.Error("Expected call to LomsRepositoryMock.GetOrderInfo")
	}
}

type mLomsRepositoryMockGetOrderStatus struct {
	mock               *LomsRepositoryMock
	defaultExpectation *LomsRepositoryMockGetOrderStatusExpectation
	expectations       []*LomsRepositoryMockGetOrderStatusExpectation

	callArgs []*LomsRepositoryMockGetOrderStatusParams
	mutex    sync.RWMutex
}

// LomsRepositoryMockGetOrderStatusExpectation specifies expectation struct of the LomsRepository.GetOrderStatus
type LomsRepositoryMockGetOrderStatusExpectation struct {
	mock    *LomsRepositoryMock
	params  *LomsRepositoryMockGetOrderStatusParams
	results *LomsRepositoryMockGetOrderStatusResults
	Counter uint64
}

// LomsRepositoryMockGetOrderStatusParams contains parameters of the LomsRepository.GetOrderStatus
type LomsRepositoryMockGetOrderStatusParams struct {
	ctx     context.Context
	orderId int64
}

// LomsRepositoryMockGetOrderStatusResults contains results of the LomsRepository.GetOrderStatus
type LomsRepositoryMockGetOrderStatusResults struct {
	s1  string
	err error
}

// Expect sets up expected params for LomsRepository.GetOrderStatus
func (mmGetOrderStatus *mLomsRepositoryMockGetOrderStatus) Expect(ctx context.Context, orderId int64) *mLomsRepositoryMockGetOrderStatus {
	if mmGetOrderStatus.mock.funcGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("LomsRepositoryMock.GetOrderStatus mock is already set by Set")
	}

	if mmGetOrderStatus.defaultExpectation == nil {
		mmGetOrderStatus.defaultExpectation = &LomsRepositoryMockGetOrderStatusExpectation{}
	}

	mmGetOrderStatus.defaultExpectation.params = &LomsRepositoryMockGetOrderStatusParams{ctx, orderId}
	for _, e := range mmGetOrderStatus.expectations {
		if minimock.Equal(e.params, mmGetOrderStatus.defaultExpectation.params) {
			mmGetOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderStatus.defaultExpectation.params)
		}
	}

	return mmGetOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the LomsRepository.GetOrderStatus
func (mmGetOrderStatus *mLomsRepositoryMockGetOrderStatus) Inspect(f func(ctx context.Context, orderId int64)) *mLomsRepositoryMockGetOrderStatus {
	if mmGetOrderStatus.mock.inspectFuncGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("Inspect function is already set for LomsRepositoryMock.GetOrderStatus")
	}

	mmGetOrderStatus.mock.inspectFuncGetOrderStatus = f

	return mmGetOrderStatus
}

// Return sets up results that will be returned by LomsRepository.GetOrderStatus
func (mmGetOrderStatus *mLomsRepositoryMockGetOrderStatus) Return(s1 string, err error) *LomsRepositoryMock {
	if mmGetOrderStatus.mock.funcGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("LomsRepositoryMock.GetOrderStatus mock is already set by Set")
	}

	if mmGetOrderStatus.defaultExpectation == nil {
		mmGetOrderStatus.defaultExpectation = &LomsRepositoryMockGetOrderStatusExpectation{mock: mmGetOrderStatus.mock}
	}
	mmGetOrderStatus.defaultExpectation.results = &LomsRepositoryMockGetOrderStatusResults{s1, err}
	return mmGetOrderStatus.mock
}

// Set uses given function f to mock the LomsRepository.GetOrderStatus method
func (mmGetOrderStatus *mLomsRepositoryMockGetOrderStatus) Set(f func(ctx context.Context, orderId int64) (s1 string, err error)) *LomsRepositoryMock {
	if mmGetOrderStatus.defaultExpectation != nil {
		mmGetOrderStatus.mock.t.Fatalf("Default expectation is already set for the LomsRepository.GetOrderStatus method")
	}

	if len(mmGetOrderStatus.expectations) > 0 {
		mmGetOrderStatus.mock.t.Fatalf("Some expectations are already set for the LomsRepository.GetOrderStatus method")
	}

	mmGetOrderStatus.mock.funcGetOrderStatus = f
	return mmGetOrderStatus.mock
}

// When sets expectation for the LomsRepository.GetOrderStatus which will trigger the result defined by the following
// Then helper
func (mmGetOrderStatus *mLomsRepositoryMockGetOrderStatus) When(ctx context.Context, orderId int64) *LomsRepositoryMockGetOrderStatusExpectation {
	if mmGetOrderStatus.mock.funcGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("LomsRepositoryMock.GetOrderStatus mock is already set by Set")
	}

	expectation := &LomsRepositoryMockGetOrderStatusExpectation{
		mock:   mmGetOrderStatus.mock,
		params: &LomsRepositoryMockGetOrderStatusParams{ctx, orderId},
	}
	mmGetOrderStatus.expectations = append(mmGetOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up LomsRepository.GetOrderStatus return parameters for the expectation previously defined by the When method
func (e *LomsRepositoryMockGetOrderStatusExpectation) Then(s1 string, err error) *LomsRepositoryMock {
	e.results = &LomsRepositoryMockGetOrderStatusResults{s1, err}
	return e.mock
}

// GetOrderStatus implements repository.LomsRepository
func (mmGetOrderStatus *LomsRepositoryMock) GetOrderStatus(ctx context.Context, orderId int64) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetOrderStatus.beforeGetOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderStatus.afterGetOrderStatusCounter, 1)

	if mmGetOrderStatus.inspectFuncGetOrderStatus != nil {
		mmGetOrderStatus.inspectFuncGetOrderStatus(ctx, orderId)
	}

	mm_params := &LomsRepositoryMockGetOrderStatusParams{ctx, orderId}

	// Record call args
	mmGetOrderStatus.GetOrderStatusMock.mutex.Lock()
	mmGetOrderStatus.GetOrderStatusMock.callArgs = append(mmGetOrderStatus.GetOrderStatusMock.callArgs, mm_params)
	mmGetOrderStatus.GetOrderStatusMock.mutex.Unlock()

	for _, e := range mmGetOrderStatus.GetOrderStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetOrderStatus.GetOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.params
		mm_got := LomsRepositoryMockGetOrderStatusParams{ctx, orderId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderStatus.t.Errorf("LomsRepositoryMock.GetOrderStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderStatus.t.Fatal("No results are set for the LomsRepositoryMock.GetOrderStatus")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetOrderStatus.funcGetOrderStatus != nil {
		return mmGetOrderStatus.funcGetOrderStatus(ctx, orderId)
	}
	mmGetOrderStatus.t.Fatalf("Unexpected call to LomsRepositoryMock.GetOrderStatus. %v %v", ctx, orderId)
	return
}

// GetOrderStatusAfterCounter returns a count of finished LomsRepositoryMock.GetOrderStatus invocations
func (mmGetOrderStatus *LomsRepositoryMock) GetOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderStatus.afterGetOrderStatusCounter)
}

// GetOrderStatusBeforeCounter returns a count of LomsRepositoryMock.GetOrderStatus invocations
func (mmGetOrderStatus *LomsRepositoryMock) GetOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderStatus.beforeGetOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to LomsRepositoryMock.GetOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderStatus *mLomsRepositoryMockGetOrderStatus) Calls() []*LomsRepositoryMockGetOrderStatusParams {
	mmGetOrderStatus.mutex.RLock()

	argCopy := make([]*LomsRepositoryMockGetOrderStatusParams, len(mmGetOrderStatus.callArgs))
	copy(argCopy, mmGetOrderStatus.callArgs)

	mmGetOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderStatusDone returns true if the count of the GetOrderStatus invocations corresponds
// the number of defined expectations
func (m *LomsRepositoryMock) MinimockGetOrderStatusDone() bool {
	for _, e := range m.GetOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderStatus != nil && mm_atomic.LoadUint64(&m.afterGetOrderStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderStatusInspect logs each unmet expectation
func (m *LomsRepositoryMock) MinimockGetOrderStatusInspect() {
	for _, e := range m.GetOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsRepositoryMock.GetOrderStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderStatusCounter) < 1 {
		if m.GetOrderStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsRepositoryMock.GetOrderStatus")
		} else {
			m.t.Errorf("Expected call to LomsRepositoryMock.GetOrderStatus with params: %#v", *m.GetOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderStatus != nil && mm_atomic.LoadUint64(&m.afterGetOrderStatusCounter) < 1 {
		m.t.Error("Expected call to LomsRepositoryMock.GetOrderStatus")
	}
}

type mLomsRepositoryMockGetOutdatedOrders struct {
	mock               *LomsRepositoryMock
	defaultExpectation *LomsRepositoryMockGetOutdatedOrdersExpectation
	expectations       []*LomsRepositoryMockGetOutdatedOrdersExpectation

	callArgs []*LomsRepositoryMockGetOutdatedOrdersParams
	mutex    sync.RWMutex
}

// LomsRepositoryMockGetOutdatedOrdersExpectation specifies expectation struct of the LomsRepository.GetOutdatedOrders
type LomsRepositoryMockGetOutdatedOrdersExpectation struct {
	mock    *LomsRepositoryMock
	params  *LomsRepositoryMockGetOutdatedOrdersParams
	results *LomsRepositoryMockGetOutdatedOrdersResults
	Counter uint64
}

// LomsRepositoryMockGetOutdatedOrdersParams contains parameters of the LomsRepository.GetOutdatedOrders
type LomsRepositoryMockGetOutdatedOrdersParams struct {
	ctx context.Context
}

// LomsRepositoryMockGetOutdatedOrdersResults contains results of the LomsRepository.GetOutdatedOrders
type LomsRepositoryMockGetOutdatedOrdersResults struct {
	ia1 []int64
	err error
}

// Expect sets up expected params for LomsRepository.GetOutdatedOrders
func (mmGetOutdatedOrders *mLomsRepositoryMockGetOutdatedOrders) Expect(ctx context.Context) *mLomsRepositoryMockGetOutdatedOrders {
	if mmGetOutdatedOrders.mock.funcGetOutdatedOrders != nil {
		mmGetOutdatedOrders.mock.t.Fatalf("LomsRepositoryMock.GetOutdatedOrders mock is already set by Set")
	}

	if mmGetOutdatedOrders.defaultExpectation == nil {
		mmGetOutdatedOrders.defaultExpectation = &LomsRepositoryMockGetOutdatedOrdersExpectation{}
	}

	mmGetOutdatedOrders.defaultExpectation.params = &LomsRepositoryMockGetOutdatedOrdersParams{ctx}
	for _, e := range mmGetOutdatedOrders.expectations {
		if minimock.Equal(e.params, mmGetOutdatedOrders.defaultExpectation.params) {
			mmGetOutdatedOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOutdatedOrders.defaultExpectation.params)
		}
	}

	return mmGetOutdatedOrders
}

// Inspect accepts an inspector function that has same arguments as the LomsRepository.GetOutdatedOrders
func (mmGetOutdatedOrders *mLomsRepositoryMockGetOutdatedOrders) Inspect(f func(ctx context.Context)) *mLomsRepositoryMockGetOutdatedOrders {
	if mmGetOutdatedOrders.mock.inspectFuncGetOutdatedOrders != nil {
		mmGetOutdatedOrders.mock.t.Fatalf("Inspect function is already set for LomsRepositoryMock.GetOutdatedOrders")
	}

	mmGetOutdatedOrders.mock.inspectFuncGetOutdatedOrders = f

	return mmGetOutdatedOrders
}

// Return sets up results that will be returned by LomsRepository.GetOutdatedOrders
func (mmGetOutdatedOrders *mLomsRepositoryMockGetOutdatedOrders) Return(ia1 []int64, err error) *LomsRepositoryMock {
	if mmGetOutdatedOrders.mock.funcGetOutdatedOrders != nil {
		mmGetOutdatedOrders.mock.t.Fatalf("LomsRepositoryMock.GetOutdatedOrders mock is already set by Set")
	}

	if mmGetOutdatedOrders.defaultExpectation == nil {
		mmGetOutdatedOrders.defaultExpectation = &LomsRepositoryMockGetOutdatedOrdersExpectation{mock: mmGetOutdatedOrders.mock}
	}
	mmGetOutdatedOrders.defaultExpectation.results = &LomsRepositoryMockGetOutdatedOrdersResults{ia1, err}
	return mmGetOutdatedOrders.mock
}

// Set uses given function f to mock the LomsRepository.GetOutdatedOrders method
func (mmGetOutdatedOrders *mLomsRepositoryMockGetOutdatedOrders) Set(f func(ctx context.Context) (ia1 []int64, err error)) *LomsRepositoryMock {
	if mmGetOutdatedOrders.defaultExpectation != nil {
		mmGetOutdatedOrders.mock.t.Fatalf("Default expectation is already set for the LomsRepository.GetOutdatedOrders method")
	}

	if len(mmGetOutdatedOrders.expectations) > 0 {
		mmGetOutdatedOrders.mock.t.Fatalf("Some expectations are already set for the LomsRepository.GetOutdatedOrders method")
	}

	mmGetOutdatedOrders.mock.funcGetOutdatedOrders = f
	return mmGetOutdatedOrders.mock
}

// When sets expectation for the LomsRepository.GetOutdatedOrders which will trigger the result defined by the following
// Then helper
func (mmGetOutdatedOrders *mLomsRepositoryMockGetOutdatedOrders) When(ctx context.Context) *LomsRepositoryMockGetOutdatedOrdersExpectation {
	if mmGetOutdatedOrders.mock.funcGetOutdatedOrders != nil {
		mmGetOutdatedOrders.mock.t.Fatalf("LomsRepositoryMock.GetOutdatedOrders mock is already set by Set")
	}

	expectation := &LomsRepositoryMockGetOutdatedOrdersExpectation{
		mock:   mmGetOutdatedOrders.mock,
		params: &LomsRepositoryMockGetOutdatedOrdersParams{ctx},
	}
	mmGetOutdatedOrders.expectations = append(mmGetOutdatedOrders.expectations, expectation)
	return expectation
}

// Then sets up LomsRepository.GetOutdatedOrders return parameters for the expectation previously defined by the When method
func (e *LomsRepositoryMockGetOutdatedOrdersExpectation) Then(ia1 []int64, err error) *LomsRepositoryMock {
	e.results = &LomsRepositoryMockGetOutdatedOrdersResults{ia1, err}
	return e.mock
}

// GetOutdatedOrders implements repository.LomsRepository
func (mmGetOutdatedOrders *LomsRepositoryMock) GetOutdatedOrders(ctx context.Context) (ia1 []int64, err error) {
	mm_atomic.AddUint64(&mmGetOutdatedOrders.beforeGetOutdatedOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOutdatedOrders.afterGetOutdatedOrdersCounter, 1)

	if mmGetOutdatedOrders.inspectFuncGetOutdatedOrders != nil {
		mmGetOutdatedOrders.inspectFuncGetOutdatedOrders(ctx)
	}

	mm_params := &LomsRepositoryMockGetOutdatedOrdersParams{ctx}

	// Record call args
	mmGetOutdatedOrders.GetOutdatedOrdersMock.mutex.Lock()
	mmGetOutdatedOrders.GetOutdatedOrdersMock.callArgs = append(mmGetOutdatedOrders.GetOutdatedOrdersMock.callArgs, mm_params)
	mmGetOutdatedOrders.GetOutdatedOrdersMock.mutex.Unlock()

	for _, e := range mmGetOutdatedOrders.GetOutdatedOrdersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetOutdatedOrders.GetOutdatedOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOutdatedOrders.GetOutdatedOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOutdatedOrders.GetOutdatedOrdersMock.defaultExpectation.params
		mm_got := LomsRepositoryMockGetOutdatedOrdersParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOutdatedOrders.t.Errorf("LomsRepositoryMock.GetOutdatedOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOutdatedOrders.GetOutdatedOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOutdatedOrders.t.Fatal("No results are set for the LomsRepositoryMock.GetOutdatedOrders")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetOutdatedOrders.funcGetOutdatedOrders != nil {
		return mmGetOutdatedOrders.funcGetOutdatedOrders(ctx)
	}
	mmGetOutdatedOrders.t.Fatalf("Unexpected call to LomsRepositoryMock.GetOutdatedOrders. %v", ctx)
	return
}

// GetOutdatedOrdersAfterCounter returns a count of finished LomsRepositoryMock.GetOutdatedOrders invocations
func (mmGetOutdatedOrders *LomsRepositoryMock) GetOutdatedOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOutdatedOrders.afterGetOutdatedOrdersCounter)
}

// GetOutdatedOrdersBeforeCounter returns a count of LomsRepositoryMock.GetOutdatedOrders invocations
func (mmGetOutdatedOrders *LomsRepositoryMock) GetOutdatedOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOutdatedOrders.beforeGetOutdatedOrdersCounter)
}

// Calls returns a list of arguments used in each call to LomsRepositoryMock.GetOutdatedOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOutdatedOrders *mLomsRepositoryMockGetOutdatedOrders) Calls() []*LomsRepositoryMockGetOutdatedOrdersParams {
	mmGetOutdatedOrders.mutex.RLock()

	argCopy := make([]*LomsRepositoryMockGetOutdatedOrdersParams, len(mmGetOutdatedOrders.callArgs))
	copy(argCopy, mmGetOutdatedOrders.callArgs)

	mmGetOutdatedOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetOutdatedOrdersDone returns true if the count of the GetOutdatedOrders invocations corresponds
// the number of defined expectations
func (m *LomsRepositoryMock) MinimockGetOutdatedOrdersDone() bool {
	for _, e := range m.GetOutdatedOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOutdatedOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOutdatedOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOutdatedOrders != nil && mm_atomic.LoadUint64(&m.afterGetOutdatedOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOutdatedOrdersInspect logs each unmet expectation
func (m *LomsRepositoryMock) MinimockGetOutdatedOrdersInspect() {
	for _, e := range m.GetOutdatedOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsRepositoryMock.GetOutdatedOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOutdatedOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOutdatedOrdersCounter) < 1 {
		if m.GetOutdatedOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsRepositoryMock.GetOutdatedOrders")
		} else {
			m.t.Errorf("Expected call to LomsRepositoryMock.GetOutdatedOrders with params: %#v", *m.GetOutdatedOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOutdatedOrders != nil && mm_atomic.LoadUint64(&m.afterGetOutdatedOrdersCounter) < 1 {
		m.t.Error("Expected call to LomsRepositoryMock.GetOutdatedOrders")
	}
}

type mLomsRepositoryMockListStocks struct {
	mock               *LomsRepositoryMock
	defaultExpectation *LomsRepositoryMockListStocksExpectation
	expectations       []*LomsRepositoryMockListStocksExpectation

	callArgs []*LomsRepositoryMockListStocksParams
	mutex    sync.RWMutex
}

// LomsRepositoryMockListStocksExpectation specifies expectation struct of the LomsRepository.ListStocks
type LomsRepositoryMockListStocksExpectation struct {
	mock    *LomsRepositoryMock
	params  *LomsRepositoryMockListStocksParams
	results *LomsRepositoryMockListStocksResults
	Counter uint64
}

// LomsRepositoryMockListStocksParams contains parameters of the LomsRepository.ListStocks
type LomsRepositoryMockListStocksParams struct {
	ctx context.Context
	sku uint32
}

// LomsRepositoryMockListStocksResults contains results of the LomsRepository.ListStocks
type LomsRepositoryMockListStocksResults struct {
	sa1 []domain.Stock
	err error
}

// Expect sets up expected params for LomsRepository.ListStocks
func (mmListStocks *mLomsRepositoryMockListStocks) Expect(ctx context.Context, sku uint32) *mLomsRepositoryMockListStocks {
	if mmListStocks.mock.funcListStocks != nil {
		mmListStocks.mock.t.Fatalf("LomsRepositoryMock.ListStocks mock is already set by Set")
	}

	if mmListStocks.defaultExpectation == nil {
		mmListStocks.defaultExpectation = &LomsRepositoryMockListStocksExpectation{}
	}

	mmListStocks.defaultExpectation.params = &LomsRepositoryMockListStocksParams{ctx, sku}
	for _, e := range mmListStocks.expectations {
		if minimock.Equal(e.params, mmListStocks.defaultExpectation.params) {
			mmListStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListStocks.defaultExpectation.params)
		}
	}

	return mmListStocks
}

// Inspect accepts an inspector function that has same arguments as the LomsRepository.ListStocks
func (mmListStocks *mLomsRepositoryMockListStocks) Inspect(f func(ctx context.Context, sku uint32)) *mLomsRepositoryMockListStocks {
	if mmListStocks.mock.inspectFuncListStocks != nil {
		mmListStocks.mock.t.Fatalf("Inspect function is already set for LomsRepositoryMock.ListStocks")
	}

	mmListStocks.mock.inspectFuncListStocks = f

	return mmListStocks
}

// Return sets up results that will be returned by LomsRepository.ListStocks
func (mmListStocks *mLomsRepositoryMockListStocks) Return(sa1 []domain.Stock, err error) *LomsRepositoryMock {
	if mmListStocks.mock.funcListStocks != nil {
		mmListStocks.mock.t.Fatalf("LomsRepositoryMock.ListStocks mock is already set by Set")
	}

	if mmListStocks.defaultExpectation == nil {
		mmListStocks.defaultExpectation = &LomsRepositoryMockListStocksExpectation{mock: mmListStocks.mock}
	}
	mmListStocks.defaultExpectation.results = &LomsRepositoryMockListStocksResults{sa1, err}
	return mmListStocks.mock
}

// Set uses given function f to mock the LomsRepository.ListStocks method
func (mmListStocks *mLomsRepositoryMockListStocks) Set(f func(ctx context.Context, sku uint32) (sa1 []domain.Stock, err error)) *LomsRepositoryMock {
	if mmListStocks.defaultExpectation != nil {
		mmListStocks.mock.t.Fatalf("Default expectation is already set for the LomsRepository.ListStocks method")
	}

	if len(mmListStocks.expectations) > 0 {
		mmListStocks.mock.t.Fatalf("Some expectations are already set for the LomsRepository.ListStocks method")
	}

	mmListStocks.mock.funcListStocks = f
	return mmListStocks.mock
}

// When sets expectation for the LomsRepository.ListStocks which will trigger the result defined by the following
// Then helper
func (mmListStocks *mLomsRepositoryMockListStocks) When(ctx context.Context, sku uint32) *LomsRepositoryMockListStocksExpectation {
	if mmListStocks.mock.funcListStocks != nil {
		mmListStocks.mock.t.Fatalf("LomsRepositoryMock.ListStocks mock is already set by Set")
	}

	expectation := &LomsRepositoryMockListStocksExpectation{
		mock:   mmListStocks.mock,
		params: &LomsRepositoryMockListStocksParams{ctx, sku},
	}
	mmListStocks.expectations = append(mmListStocks.expectations, expectation)
	return expectation
}

// Then sets up LomsRepository.ListStocks return parameters for the expectation previously defined by the When method
func (e *LomsRepositoryMockListStocksExpectation) Then(sa1 []domain.Stock, err error) *LomsRepositoryMock {
	e.results = &LomsRepositoryMockListStocksResults{sa1, err}
	return e.mock
}

// ListStocks implements repository.LomsRepository
func (mmListStocks *LomsRepositoryMock) ListStocks(ctx context.Context, sku uint32) (sa1 []domain.Stock, err error) {
	mm_atomic.AddUint64(&mmListStocks.beforeListStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmListStocks.afterListStocksCounter, 1)

	if mmListStocks.inspectFuncListStocks != nil {
		mmListStocks.inspectFuncListStocks(ctx, sku)
	}

	mm_params := &LomsRepositoryMockListStocksParams{ctx, sku}

	// Record call args
	mmListStocks.ListStocksMock.mutex.Lock()
	mmListStocks.ListStocksMock.callArgs = append(mmListStocks.ListStocksMock.callArgs, mm_params)
	mmListStocks.ListStocksMock.mutex.Unlock()

	for _, e := range mmListStocks.ListStocksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListStocks.ListStocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListStocks.ListStocksMock.defaultExpectation.Counter, 1)
		mm_want := mmListStocks.ListStocksMock.defaultExpectation.params
		mm_got := LomsRepositoryMockListStocksParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListStocks.t.Errorf("LomsRepositoryMock.ListStocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListStocks.ListStocksMock.defaultExpectation.results
		if mm_results == nil {
			mmListStocks.t.Fatal("No results are set for the LomsRepositoryMock.ListStocks")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListStocks.funcListStocks != nil {
		return mmListStocks.funcListStocks(ctx, sku)
	}
	mmListStocks.t.Fatalf("Unexpected call to LomsRepositoryMock.ListStocks. %v %v", ctx, sku)
	return
}

// ListStocksAfterCounter returns a count of finished LomsRepositoryMock.ListStocks invocations
func (mmListStocks *LomsRepositoryMock) ListStocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListStocks.afterListStocksCounter)
}

// ListStocksBeforeCounter returns a count of LomsRepositoryMock.ListStocks invocations
func (mmListStocks *LomsRepositoryMock) ListStocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListStocks.beforeListStocksCounter)
}

// Calls returns a list of arguments used in each call to LomsRepositoryMock.ListStocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListStocks *mLomsRepositoryMockListStocks) Calls() []*LomsRepositoryMockListStocksParams {
	mmListStocks.mutex.RLock()

	argCopy := make([]*LomsRepositoryMockListStocksParams, len(mmListStocks.callArgs))
	copy(argCopy, mmListStocks.callArgs)

	mmListStocks.mutex.RUnlock()

	return argCopy
}

// MinimockListStocksDone returns true if the count of the ListStocks invocations corresponds
// the number of defined expectations
func (m *LomsRepositoryMock) MinimockListStocksDone() bool {
	for _, e := range m.ListStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListStocksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListStocks != nil && mm_atomic.LoadUint64(&m.afterListStocksCounter) < 1 {
		return false
	}
	return true
}

// MinimockListStocksInspect logs each unmet expectation
func (m *LomsRepositoryMock) MinimockListStocksInspect() {
	for _, e := range m.ListStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsRepositoryMock.ListStocks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListStocksCounter) < 1 {
		if m.ListStocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsRepositoryMock.ListStocks")
		} else {
			m.t.Errorf("Expected call to LomsRepositoryMock.ListStocks with params: %#v", *m.ListStocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListStocks != nil && mm_atomic.LoadUint64(&m.afterListStocksCounter) < 1 {
		m.t.Error("Expected call to LomsRepositoryMock.ListStocks")
	}
}

type mLomsRepositoryMockRunReadCommitedTransaction struct {
	mock               *LomsRepositoryMock
	defaultExpectation *LomsRepositoryMockRunReadCommitedTransactionExpectation
	expectations       []*LomsRepositoryMockRunReadCommitedTransactionExpectation

	callArgs []*LomsRepositoryMockRunReadCommitedTransactionParams
	mutex    sync.RWMutex
}

// LomsRepositoryMockRunReadCommitedTransactionExpectation specifies expectation struct of the LomsRepository.RunReadCommitedTransaction
type LomsRepositoryMockRunReadCommitedTransactionExpectation struct {
	mock    *LomsRepositoryMock
	params  *LomsRepositoryMockRunReadCommitedTransactionParams
	results *LomsRepositoryMockRunReadCommitedTransactionResults
	Counter uint64
}

// LomsRepositoryMockRunReadCommitedTransactionParams contains parameters of the LomsRepository.RunReadCommitedTransaction
type LomsRepositoryMockRunReadCommitedTransactionParams struct {
	ctx context.Context
	fx  func(ctxTX context.Context) error
}

// LomsRepositoryMockRunReadCommitedTransactionResults contains results of the LomsRepository.RunReadCommitedTransaction
type LomsRepositoryMockRunReadCommitedTransactionResults struct {
	err error
}

// Expect sets up expected params for LomsRepository.RunReadCommitedTransaction
func (mmRunReadCommitedTransaction *mLomsRepositoryMockRunReadCommitedTransaction) Expect(ctx context.Context, fx func(ctxTX context.Context) error) *mLomsRepositoryMockRunReadCommitedTransaction {
	if mmRunReadCommitedTransaction.mock.funcRunReadCommitedTransaction != nil {
		mmRunReadCommitedTransaction.mock.t.Fatalf("LomsRepositoryMock.RunReadCommitedTransaction mock is already set by Set")
	}

	if mmRunReadCommitedTransaction.defaultExpectation == nil {
		mmRunReadCommitedTransaction.defaultExpectation = &LomsRepositoryMockRunReadCommitedTransactionExpectation{}
	}

	mmRunReadCommitedTransaction.defaultExpectation.params = &LomsRepositoryMockRunReadCommitedTransactionParams{ctx, fx}
	for _, e := range mmRunReadCommitedTransaction.expectations {
		if minimock.Equal(e.params, mmRunReadCommitedTransaction.defaultExpectation.params) {
			mmRunReadCommitedTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRunReadCommitedTransaction.defaultExpectation.params)
		}
	}

	return mmRunReadCommitedTransaction
}

// Inspect accepts an inspector function that has same arguments as the LomsRepository.RunReadCommitedTransaction
func (mmRunReadCommitedTransaction *mLomsRepositoryMockRunReadCommitedTransaction) Inspect(f func(ctx context.Context, fx func(ctxTX context.Context) error)) *mLomsRepositoryMockRunReadCommitedTransaction {
	if mmRunReadCommitedTransaction.mock.inspectFuncRunReadCommitedTransaction != nil {
		mmRunReadCommitedTransaction.mock.t.Fatalf("Inspect function is already set for LomsRepositoryMock.RunReadCommitedTransaction")
	}

	mmRunReadCommitedTransaction.mock.inspectFuncRunReadCommitedTransaction = f

	return mmRunReadCommitedTransaction
}

// Return sets up results that will be returned by LomsRepository.RunReadCommitedTransaction
func (mmRunReadCommitedTransaction *mLomsRepositoryMockRunReadCommitedTransaction) Return(err error) *LomsRepositoryMock {
	if mmRunReadCommitedTransaction.mock.funcRunReadCommitedTransaction != nil {
		mmRunReadCommitedTransaction.mock.t.Fatalf("LomsRepositoryMock.RunReadCommitedTransaction mock is already set by Set")
	}

	if mmRunReadCommitedTransaction.defaultExpectation == nil {
		mmRunReadCommitedTransaction.defaultExpectation = &LomsRepositoryMockRunReadCommitedTransactionExpectation{mock: mmRunReadCommitedTransaction.mock}
	}
	mmRunReadCommitedTransaction.defaultExpectation.results = &LomsRepositoryMockRunReadCommitedTransactionResults{err}
	return mmRunReadCommitedTransaction.mock
}

// Set uses given function f to mock the LomsRepository.RunReadCommitedTransaction method
func (mmRunReadCommitedTransaction *mLomsRepositoryMockRunReadCommitedTransaction) Set(f func(ctx context.Context, fx func(ctxTX context.Context) error) (err error)) *LomsRepositoryMock {
	if mmRunReadCommitedTransaction.defaultExpectation != nil {
		mmRunReadCommitedTransaction.mock.t.Fatalf("Default expectation is already set for the LomsRepository.RunReadCommitedTransaction method")
	}

	if len(mmRunReadCommitedTransaction.expectations) > 0 {
		mmRunReadCommitedTransaction.mock.t.Fatalf("Some expectations are already set for the LomsRepository.RunReadCommitedTransaction method")
	}

	mmRunReadCommitedTransaction.mock.funcRunReadCommitedTransaction = f
	return mmRunReadCommitedTransaction.mock
}

// When sets expectation for the LomsRepository.RunReadCommitedTransaction which will trigger the result defined by the following
// Then helper
func (mmRunReadCommitedTransaction *mLomsRepositoryMockRunReadCommitedTransaction) When(ctx context.Context, fx func(ctxTX context.Context) error) *LomsRepositoryMockRunReadCommitedTransactionExpectation {
	if mmRunReadCommitedTransaction.mock.funcRunReadCommitedTransaction != nil {
		mmRunReadCommitedTransaction.mock.t.Fatalf("LomsRepositoryMock.RunReadCommitedTransaction mock is already set by Set")
	}

	expectation := &LomsRepositoryMockRunReadCommitedTransactionExpectation{
		mock:   mmRunReadCommitedTransaction.mock,
		params: &LomsRepositoryMockRunReadCommitedTransactionParams{ctx, fx},
	}
	mmRunReadCommitedTransaction.expectations = append(mmRunReadCommitedTransaction.expectations, expectation)
	return expectation
}

// Then sets up LomsRepository.RunReadCommitedTransaction return parameters for the expectation previously defined by the When method
func (e *LomsRepositoryMockRunReadCommitedTransactionExpectation) Then(err error) *LomsRepositoryMock {
	e.results = &LomsRepositoryMockRunReadCommitedTransactionResults{err}
	return e.mock
}

// RunReadCommitedTransaction implements repository.LomsRepository
func (mmRunReadCommitedTransaction *LomsRepositoryMock) RunReadCommitedTransaction(ctx context.Context, fx func(ctxTX context.Context) error) (err error) {
	mm_atomic.AddUint64(&mmRunReadCommitedTransaction.beforeRunReadCommitedTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmRunReadCommitedTransaction.afterRunReadCommitedTransactionCounter, 1)

	if mmRunReadCommitedTransaction.inspectFuncRunReadCommitedTransaction != nil {
		mmRunReadCommitedTransaction.inspectFuncRunReadCommitedTransaction(ctx, fx)
	}

	mm_params := &LomsRepositoryMockRunReadCommitedTransactionParams{ctx, fx}

	// Record call args
	mmRunReadCommitedTransaction.RunReadCommitedTransactionMock.mutex.Lock()
	mmRunReadCommitedTransaction.RunReadCommitedTransactionMock.callArgs = append(mmRunReadCommitedTransaction.RunReadCommitedTransactionMock.callArgs, mm_params)
	mmRunReadCommitedTransaction.RunReadCommitedTransactionMock.mutex.Unlock()

	for _, e := range mmRunReadCommitedTransaction.RunReadCommitedTransactionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRunReadCommitedTransaction.RunReadCommitedTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRunReadCommitedTransaction.RunReadCommitedTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmRunReadCommitedTransaction.RunReadCommitedTransactionMock.defaultExpectation.params
		mm_got := LomsRepositoryMockRunReadCommitedTransactionParams{ctx, fx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRunReadCommitedTransaction.t.Errorf("LomsRepositoryMock.RunReadCommitedTransaction got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRunReadCommitedTransaction.RunReadCommitedTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmRunReadCommitedTransaction.t.Fatal("No results are set for the LomsRepositoryMock.RunReadCommitedTransaction")
		}
		return (*mm_results).err
	}
	if mmRunReadCommitedTransaction.funcRunReadCommitedTransaction != nil {
		return mmRunReadCommitedTransaction.funcRunReadCommitedTransaction(ctx, fx)
	}
	mmRunReadCommitedTransaction.t.Fatalf("Unexpected call to LomsRepositoryMock.RunReadCommitedTransaction. %v %v", ctx, fx)
	return
}

// RunReadCommitedTransactionAfterCounter returns a count of finished LomsRepositoryMock.RunReadCommitedTransaction invocations
func (mmRunReadCommitedTransaction *LomsRepositoryMock) RunReadCommitedTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunReadCommitedTransaction.afterRunReadCommitedTransactionCounter)
}

// RunReadCommitedTransactionBeforeCounter returns a count of LomsRepositoryMock.RunReadCommitedTransaction invocations
func (mmRunReadCommitedTransaction *LomsRepositoryMock) RunReadCommitedTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunReadCommitedTransaction.beforeRunReadCommitedTransactionCounter)
}

// Calls returns a list of arguments used in each call to LomsRepositoryMock.RunReadCommitedTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRunReadCommitedTransaction *mLomsRepositoryMockRunReadCommitedTransaction) Calls() []*LomsRepositoryMockRunReadCommitedTransactionParams {
	mmRunReadCommitedTransaction.mutex.RLock()

	argCopy := make([]*LomsRepositoryMockRunReadCommitedTransactionParams, len(mmRunReadCommitedTransaction.callArgs))
	copy(argCopy, mmRunReadCommitedTransaction.callArgs)

	mmRunReadCommitedTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockRunReadCommitedTransactionDone returns true if the count of the RunReadCommitedTransaction invocations corresponds
// the number of defined expectations
func (m *LomsRepositoryMock) MinimockRunReadCommitedTransactionDone() bool {
	for _, e := range m.RunReadCommitedTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunReadCommitedTransactionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunReadCommitedTransactionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunReadCommitedTransaction != nil && mm_atomic.LoadUint64(&m.afterRunReadCommitedTransactionCounter) < 1 {
		return false
	}
	return true
}

// MinimockRunReadCommitedTransactionInspect logs each unmet expectation
func (m *LomsRepositoryMock) MinimockRunReadCommitedTransactionInspect() {
	for _, e := range m.RunReadCommitedTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsRepositoryMock.RunReadCommitedTransaction with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunReadCommitedTransactionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunReadCommitedTransactionCounter) < 1 {
		if m.RunReadCommitedTransactionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsRepositoryMock.RunReadCommitedTransaction")
		} else {
			m.t.Errorf("Expected call to LomsRepositoryMock.RunReadCommitedTransaction with params: %#v", *m.RunReadCommitedTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunReadCommitedTransaction != nil && mm_atomic.LoadUint64(&m.afterRunReadCommitedTransactionCounter) < 1 {
		m.t.Error("Expected call to LomsRepositoryMock.RunReadCommitedTransaction")
	}
}

type mLomsRepositoryMockUpdateOrderStatus struct {
	mock               *LomsRepositoryMock
	defaultExpectation *LomsRepositoryMockUpdateOrderStatusExpectation
	expectations       []*LomsRepositoryMockUpdateOrderStatusExpectation

	callArgs []*LomsRepositoryMockUpdateOrderStatusParams
	mutex    sync.RWMutex
}

// LomsRepositoryMockUpdateOrderStatusExpectation specifies expectation struct of the LomsRepository.UpdateOrderStatus
type LomsRepositoryMockUpdateOrderStatusExpectation struct {
	mock    *LomsRepositoryMock
	params  *LomsRepositoryMockUpdateOrderStatusParams
	results *LomsRepositoryMockUpdateOrderStatusResults
	Counter uint64
}

// LomsRepositoryMockUpdateOrderStatusParams contains parameters of the LomsRepository.UpdateOrderStatus
type LomsRepositoryMockUpdateOrderStatusParams struct {
	ctx     context.Context
	orderId int64
	status  string
}

// LomsRepositoryMockUpdateOrderStatusResults contains results of the LomsRepository.UpdateOrderStatus
type LomsRepositoryMockUpdateOrderStatusResults struct {
	err error
}

// Expect sets up expected params for LomsRepository.UpdateOrderStatus
func (mmUpdateOrderStatus *mLomsRepositoryMockUpdateOrderStatus) Expect(ctx context.Context, orderId int64, status string) *mLomsRepositoryMockUpdateOrderStatus {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("LomsRepositoryMock.UpdateOrderStatus mock is already set by Set")
	}

	if mmUpdateOrderStatus.defaultExpectation == nil {
		mmUpdateOrderStatus.defaultExpectation = &LomsRepositoryMockUpdateOrderStatusExpectation{}
	}

	mmUpdateOrderStatus.defaultExpectation.params = &LomsRepositoryMockUpdateOrderStatusParams{ctx, orderId, status}
	for _, e := range mmUpdateOrderStatus.expectations {
		if minimock.Equal(e.params, mmUpdateOrderStatus.defaultExpectation.params) {
			mmUpdateOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrderStatus.defaultExpectation.params)
		}
	}

	return mmUpdateOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the LomsRepository.UpdateOrderStatus
func (mmUpdateOrderStatus *mLomsRepositoryMockUpdateOrderStatus) Inspect(f func(ctx context.Context, orderId int64, status string)) *mLomsRepositoryMockUpdateOrderStatus {
	if mmUpdateOrderStatus.mock.inspectFuncUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("Inspect function is already set for LomsRepositoryMock.UpdateOrderStatus")
	}

	mmUpdateOrderStatus.mock.inspectFuncUpdateOrderStatus = f

	return mmUpdateOrderStatus
}

// Return sets up results that will be returned by LomsRepository.UpdateOrderStatus
func (mmUpdateOrderStatus *mLomsRepositoryMockUpdateOrderStatus) Return(err error) *LomsRepositoryMock {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("LomsRepositoryMock.UpdateOrderStatus mock is already set by Set")
	}

	if mmUpdateOrderStatus.defaultExpectation == nil {
		mmUpdateOrderStatus.defaultExpectation = &LomsRepositoryMockUpdateOrderStatusExpectation{mock: mmUpdateOrderStatus.mock}
	}
	mmUpdateOrderStatus.defaultExpectation.results = &LomsRepositoryMockUpdateOrderStatusResults{err}
	return mmUpdateOrderStatus.mock
}

// Set uses given function f to mock the LomsRepository.UpdateOrderStatus method
func (mmUpdateOrderStatus *mLomsRepositoryMockUpdateOrderStatus) Set(f func(ctx context.Context, orderId int64, status string) (err error)) *LomsRepositoryMock {
	if mmUpdateOrderStatus.defaultExpectation != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("Default expectation is already set for the LomsRepository.UpdateOrderStatus method")
	}

	if len(mmUpdateOrderStatus.expectations) > 0 {
		mmUpdateOrderStatus.mock.t.Fatalf("Some expectations are already set for the LomsRepository.UpdateOrderStatus method")
	}

	mmUpdateOrderStatus.mock.funcUpdateOrderStatus = f
	return mmUpdateOrderStatus.mock
}

// When sets expectation for the LomsRepository.UpdateOrderStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateOrderStatus *mLomsRepositoryMockUpdateOrderStatus) When(ctx context.Context, orderId int64, status string) *LomsRepositoryMockUpdateOrderStatusExpectation {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("LomsRepositoryMock.UpdateOrderStatus mock is already set by Set")
	}

	expectation := &LomsRepositoryMockUpdateOrderStatusExpectation{
		mock:   mmUpdateOrderStatus.mock,
		params: &LomsRepositoryMockUpdateOrderStatusParams{ctx, orderId, status},
	}
	mmUpdateOrderStatus.expectations = append(mmUpdateOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up LomsRepository.UpdateOrderStatus return parameters for the expectation previously defined by the When method
func (e *LomsRepositoryMockUpdateOrderStatusExpectation) Then(err error) *LomsRepositoryMock {
	e.results = &LomsRepositoryMockUpdateOrderStatusResults{err}
	return e.mock
}

// UpdateOrderStatus implements repository.LomsRepository
func (mmUpdateOrderStatus *LomsRepositoryMock) UpdateOrderStatus(ctx context.Context, orderId int64, status string) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrderStatus.beforeUpdateOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrderStatus.afterUpdateOrderStatusCounter, 1)

	if mmUpdateOrderStatus.inspectFuncUpdateOrderStatus != nil {
		mmUpdateOrderStatus.inspectFuncUpdateOrderStatus(ctx, orderId, status)
	}

	mm_params := &LomsRepositoryMockUpdateOrderStatusParams{ctx, orderId, status}

	// Record call args
	mmUpdateOrderStatus.UpdateOrderStatusMock.mutex.Lock()
	mmUpdateOrderStatus.UpdateOrderStatusMock.callArgs = append(mmUpdateOrderStatus.UpdateOrderStatusMock.callArgs, mm_params)
	mmUpdateOrderStatus.UpdateOrderStatusMock.mutex.Unlock()

	for _, e := range mmUpdateOrderStatus.UpdateOrderStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.params
		mm_got := LomsRepositoryMockUpdateOrderStatusParams{ctx, orderId, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrderStatus.t.Errorf("LomsRepositoryMock.UpdateOrderStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrderStatus.t.Fatal("No results are set for the LomsRepositoryMock.UpdateOrderStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateOrderStatus.funcUpdateOrderStatus != nil {
		return mmUpdateOrderStatus.funcUpdateOrderStatus(ctx, orderId, status)
	}
	mmUpdateOrderStatus.t.Fatalf("Unexpected call to LomsRepositoryMock.UpdateOrderStatus. %v %v %v", ctx, orderId, status)
	return
}

// UpdateOrderStatusAfterCounter returns a count of finished LomsRepositoryMock.UpdateOrderStatus invocations
func (mmUpdateOrderStatus *LomsRepositoryMock) UpdateOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderStatus.afterUpdateOrderStatusCounter)
}

// UpdateOrderStatusBeforeCounter returns a count of LomsRepositoryMock.UpdateOrderStatus invocations
func (mmUpdateOrderStatus *LomsRepositoryMock) UpdateOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderStatus.beforeUpdateOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to LomsRepositoryMock.UpdateOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrderStatus *mLomsRepositoryMockUpdateOrderStatus) Calls() []*LomsRepositoryMockUpdateOrderStatusParams {
	mmUpdateOrderStatus.mutex.RLock()

	argCopy := make([]*LomsRepositoryMockUpdateOrderStatusParams, len(mmUpdateOrderStatus.callArgs))
	copy(argCopy, mmUpdateOrderStatus.callArgs)

	mmUpdateOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderStatusDone returns true if the count of the UpdateOrderStatus invocations corresponds
// the number of defined expectations
func (m *LomsRepositoryMock) MinimockUpdateOrderStatusDone() bool {
	for _, e := range m.UpdateOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderStatusInspect logs each unmet expectation
func (m *LomsRepositoryMock) MinimockUpdateOrderStatusInspect() {
	for _, e := range m.UpdateOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsRepositoryMock.UpdateOrderStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		if m.UpdateOrderStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsRepositoryMock.UpdateOrderStatus")
		} else {
			m.t.Errorf("Expected call to LomsRepositoryMock.UpdateOrderStatus with params: %#v", *m.UpdateOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		m.t.Error("Expected call to LomsRepositoryMock.UpdateOrderStatus")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LomsRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockApplyOrderReservationsInspect()

		m.MinimockClearReservationsInspect()

		m.MinimockCreateOrderInspect()

		m.MinimockCreateOrderItemsInspect()

		m.MinimockCreateReservationInspect()

		m.MinimockGetOrderInfoInspect()

		m.MinimockGetOrderStatusInspect()

		m.MinimockGetOutdatedOrdersInspect()

		m.MinimockListStocksInspect()

		m.MinimockRunReadCommitedTransactionInspect()

		m.MinimockUpdateOrderStatusInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LomsRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LomsRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockApplyOrderReservationsDone() &&
		m.MinimockClearReservationsDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockCreateOrderItemsDone() &&
		m.MinimockCreateReservationDone() &&
		m.MinimockGetOrderInfoDone() &&
		m.MinimockGetOrderStatusDone() &&
		m.MinimockGetOutdatedOrdersDone() &&
		m.MinimockListStocksDone() &&
		m.MinimockRunReadCommitedTransactionDone() &&
		m.MinimockUpdateOrderStatusDone()
}

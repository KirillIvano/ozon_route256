package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/repository.CheckoutRepository -o ./mocks/checkout_repository_minimock.go -n CheckoutRepositoryMock

import (
	"context"
	"route256/checkout/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CheckoutRepositoryMock implements repository.CheckoutRepository
type CheckoutRepositoryMock struct {
	t minimock.Tester

	funcAddToCart          func(ctx context.Context, userId int64, sku uint32, count uint32) (err error)
	inspectFuncAddToCart   func(ctx context.Context, userId int64, sku uint32, count uint32)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mCheckoutRepositoryMockAddToCart

	funcDeleteCart          func(ctx context.Context, userId int64) (err error)
	inspectFuncDeleteCart   func(ctx context.Context, userId int64)
	afterDeleteCartCounter  uint64
	beforeDeleteCartCounter uint64
	DeleteCartMock          mCheckoutRepositoryMockDeleteCart

	funcDeleteItem          func(ctx context.Context, userId int64, sku uint32, count uint32) (err error)
	inspectFuncDeleteItem   func(ctx context.Context, userId int64, sku uint32, count uint32)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mCheckoutRepositoryMockDeleteItem

	funcGetCartItemExists          func(ctx context.Context, userId int64, sku uint32) (b1 bool, err error)
	inspectFuncGetCartItemExists   func(ctx context.Context, userId int64, sku uint32)
	afterGetCartItemExistsCounter  uint64
	beforeGetCartItemExistsCounter uint64
	GetCartItemExistsMock          mCheckoutRepositoryMockGetCartItemExists

	funcGetCartItems          func(ctx context.Context, userId int64) (ca1 []domain.CartItem, err error)
	inspectFuncGetCartItems   func(ctx context.Context, userId int64)
	afterGetCartItemsCounter  uint64
	beforeGetCartItemsCounter uint64
	GetCartItemsMock          mCheckoutRepositoryMockGetCartItems
}

// NewCheckoutRepositoryMock returns a mock for repository.CheckoutRepository
func NewCheckoutRepositoryMock(t minimock.Tester) *CheckoutRepositoryMock {
	m := &CheckoutRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mCheckoutRepositoryMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*CheckoutRepositoryMockAddToCartParams{}

	m.DeleteCartMock = mCheckoutRepositoryMockDeleteCart{mock: m}
	m.DeleteCartMock.callArgs = []*CheckoutRepositoryMockDeleteCartParams{}

	m.DeleteItemMock = mCheckoutRepositoryMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*CheckoutRepositoryMockDeleteItemParams{}

	m.GetCartItemExistsMock = mCheckoutRepositoryMockGetCartItemExists{mock: m}
	m.GetCartItemExistsMock.callArgs = []*CheckoutRepositoryMockGetCartItemExistsParams{}

	m.GetCartItemsMock = mCheckoutRepositoryMockGetCartItems{mock: m}
	m.GetCartItemsMock.callArgs = []*CheckoutRepositoryMockGetCartItemsParams{}

	return m
}

type mCheckoutRepositoryMockAddToCart struct {
	mock               *CheckoutRepositoryMock
	defaultExpectation *CheckoutRepositoryMockAddToCartExpectation
	expectations       []*CheckoutRepositoryMockAddToCartExpectation

	callArgs []*CheckoutRepositoryMockAddToCartParams
	mutex    sync.RWMutex
}

// CheckoutRepositoryMockAddToCartExpectation specifies expectation struct of the CheckoutRepository.AddToCart
type CheckoutRepositoryMockAddToCartExpectation struct {
	mock    *CheckoutRepositoryMock
	params  *CheckoutRepositoryMockAddToCartParams
	results *CheckoutRepositoryMockAddToCartResults
	Counter uint64
}

// CheckoutRepositoryMockAddToCartParams contains parameters of the CheckoutRepository.AddToCart
type CheckoutRepositoryMockAddToCartParams struct {
	ctx    context.Context
	userId int64
	sku    uint32
	count  uint32
}

// CheckoutRepositoryMockAddToCartResults contains results of the CheckoutRepository.AddToCart
type CheckoutRepositoryMockAddToCartResults struct {
	err error
}

// Expect sets up expected params for CheckoutRepository.AddToCart
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) Expect(ctx context.Context, userId int64, sku uint32, count uint32) *mCheckoutRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CheckoutRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CheckoutRepositoryMockAddToCartExpectation{}
	}

	mmAddToCart.defaultExpectation.params = &CheckoutRepositoryMockAddToCartParams{ctx, userId, sku, count}
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepository.AddToCart
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) Inspect(f func(ctx context.Context, userId int64, sku uint32, count uint32)) *mCheckoutRepositoryMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for CheckoutRepositoryMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by CheckoutRepository.AddToCart
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) Return(err error) *CheckoutRepositoryMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CheckoutRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CheckoutRepositoryMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &CheckoutRepositoryMockAddToCartResults{err}
	return mmAddToCart.mock
}

// Set uses given function f to mock the CheckoutRepository.AddToCart method
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) Set(f func(ctx context.Context, userId int64, sku uint32, count uint32) (err error)) *CheckoutRepositoryMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the CheckoutRepository.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the CheckoutRepository.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	return mmAddToCart.mock
}

// When sets expectation for the CheckoutRepository.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) When(ctx context.Context, userId int64, sku uint32, count uint32) *CheckoutRepositoryMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CheckoutRepositoryMock.AddToCart mock is already set by Set")
	}

	expectation := &CheckoutRepositoryMockAddToCartExpectation{
		mock:   mmAddToCart.mock,
		params: &CheckoutRepositoryMockAddToCartParams{ctx, userId, sku, count},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepository.AddToCart return parameters for the expectation previously defined by the When method
func (e *CheckoutRepositoryMockAddToCartExpectation) Then(err error) *CheckoutRepositoryMock {
	e.results = &CheckoutRepositoryMockAddToCartResults{err}
	return e.mock
}

// AddToCart implements repository.CheckoutRepository
func (mmAddToCart *CheckoutRepositoryMock) AddToCart(ctx context.Context, userId int64, sku uint32, count uint32) (err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, userId, sku, count)
	}

	mm_params := &CheckoutRepositoryMockAddToCartParams{ctx, userId, sku, count}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_got := CheckoutRepositoryMockAddToCartParams{ctx, userId, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("CheckoutRepositoryMock.AddToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the CheckoutRepositoryMock.AddToCart")
		}
		return (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, userId, sku, count)
	}
	mmAddToCart.t.Fatalf("Unexpected call to CheckoutRepositoryMock.AddToCart. %v %v %v %v", ctx, userId, sku, count)
	return
}

// AddToCartAfterCounter returns a count of finished CheckoutRepositoryMock.AddToCart invocations
func (mmAddToCart *CheckoutRepositoryMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of CheckoutRepositoryMock.AddToCart invocations
func (mmAddToCart *CheckoutRepositoryMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepositoryMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mCheckoutRepositoryMockAddToCart) Calls() []*CheckoutRepositoryMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*CheckoutRepositoryMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *CheckoutRepositoryMock) MinimockAddToCartDone() bool {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *CheckoutRepositoryMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.AddToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepositoryMock.AddToCart")
		} else {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.AddToCart with params: %#v", *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepositoryMock.AddToCart")
	}
}

type mCheckoutRepositoryMockDeleteCart struct {
	mock               *CheckoutRepositoryMock
	defaultExpectation *CheckoutRepositoryMockDeleteCartExpectation
	expectations       []*CheckoutRepositoryMockDeleteCartExpectation

	callArgs []*CheckoutRepositoryMockDeleteCartParams
	mutex    sync.RWMutex
}

// CheckoutRepositoryMockDeleteCartExpectation specifies expectation struct of the CheckoutRepository.DeleteCart
type CheckoutRepositoryMockDeleteCartExpectation struct {
	mock    *CheckoutRepositoryMock
	params  *CheckoutRepositoryMockDeleteCartParams
	results *CheckoutRepositoryMockDeleteCartResults
	Counter uint64
}

// CheckoutRepositoryMockDeleteCartParams contains parameters of the CheckoutRepository.DeleteCart
type CheckoutRepositoryMockDeleteCartParams struct {
	ctx    context.Context
	userId int64
}

// CheckoutRepositoryMockDeleteCartResults contains results of the CheckoutRepository.DeleteCart
type CheckoutRepositoryMockDeleteCartResults struct {
	err error
}

// Expect sets up expected params for CheckoutRepository.DeleteCart
func (mmDeleteCart *mCheckoutRepositoryMockDeleteCart) Expect(ctx context.Context, userId int64) *mCheckoutRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CheckoutRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CheckoutRepositoryMockDeleteCartExpectation{}
	}

	mmDeleteCart.defaultExpectation.params = &CheckoutRepositoryMockDeleteCartParams{ctx, userId}
	for _, e := range mmDeleteCart.expectations {
		if minimock.Equal(e.params, mmDeleteCart.defaultExpectation.params) {
			mmDeleteCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCart.defaultExpectation.params)
		}
	}

	return mmDeleteCart
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepository.DeleteCart
func (mmDeleteCart *mCheckoutRepositoryMockDeleteCart) Inspect(f func(ctx context.Context, userId int64)) *mCheckoutRepositoryMockDeleteCart {
	if mmDeleteCart.mock.inspectFuncDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("Inspect function is already set for CheckoutRepositoryMock.DeleteCart")
	}

	mmDeleteCart.mock.inspectFuncDeleteCart = f

	return mmDeleteCart
}

// Return sets up results that will be returned by CheckoutRepository.DeleteCart
func (mmDeleteCart *mCheckoutRepositoryMockDeleteCart) Return(err error) *CheckoutRepositoryMock {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CheckoutRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CheckoutRepositoryMockDeleteCartExpectation{mock: mmDeleteCart.mock}
	}
	mmDeleteCart.defaultExpectation.results = &CheckoutRepositoryMockDeleteCartResults{err}
	return mmDeleteCart.mock
}

// Set uses given function f to mock the CheckoutRepository.DeleteCart method
func (mmDeleteCart *mCheckoutRepositoryMockDeleteCart) Set(f func(ctx context.Context, userId int64) (err error)) *CheckoutRepositoryMock {
	if mmDeleteCart.defaultExpectation != nil {
		mmDeleteCart.mock.t.Fatalf("Default expectation is already set for the CheckoutRepository.DeleteCart method")
	}

	if len(mmDeleteCart.expectations) > 0 {
		mmDeleteCart.mock.t.Fatalf("Some expectations are already set for the CheckoutRepository.DeleteCart method")
	}

	mmDeleteCart.mock.funcDeleteCart = f
	return mmDeleteCart.mock
}

// When sets expectation for the CheckoutRepository.DeleteCart which will trigger the result defined by the following
// Then helper
func (mmDeleteCart *mCheckoutRepositoryMockDeleteCart) When(ctx context.Context, userId int64) *CheckoutRepositoryMockDeleteCartExpectation {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CheckoutRepositoryMock.DeleteCart mock is already set by Set")
	}

	expectation := &CheckoutRepositoryMockDeleteCartExpectation{
		mock:   mmDeleteCart.mock,
		params: &CheckoutRepositoryMockDeleteCartParams{ctx, userId},
	}
	mmDeleteCart.expectations = append(mmDeleteCart.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepository.DeleteCart return parameters for the expectation previously defined by the When method
func (e *CheckoutRepositoryMockDeleteCartExpectation) Then(err error) *CheckoutRepositoryMock {
	e.results = &CheckoutRepositoryMockDeleteCartResults{err}
	return e.mock
}

// DeleteCart implements repository.CheckoutRepository
func (mmDeleteCart *CheckoutRepositoryMock) DeleteCart(ctx context.Context, userId int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteCart.beforeDeleteCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCart.afterDeleteCartCounter, 1)

	if mmDeleteCart.inspectFuncDeleteCart != nil {
		mmDeleteCart.inspectFuncDeleteCart(ctx, userId)
	}

	mm_params := &CheckoutRepositoryMockDeleteCartParams{ctx, userId}

	// Record call args
	mmDeleteCart.DeleteCartMock.mutex.Lock()
	mmDeleteCart.DeleteCartMock.callArgs = append(mmDeleteCart.DeleteCartMock.callArgs, mm_params)
	mmDeleteCart.DeleteCartMock.mutex.Unlock()

	for _, e := range mmDeleteCart.DeleteCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCart.DeleteCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCart.DeleteCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCart.DeleteCartMock.defaultExpectation.params
		mm_got := CheckoutRepositoryMockDeleteCartParams{ctx, userId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCart.t.Errorf("CheckoutRepositoryMock.DeleteCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCart.DeleteCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCart.t.Fatal("No results are set for the CheckoutRepositoryMock.DeleteCart")
		}
		return (*mm_results).err
	}
	if mmDeleteCart.funcDeleteCart != nil {
		return mmDeleteCart.funcDeleteCart(ctx, userId)
	}
	mmDeleteCart.t.Fatalf("Unexpected call to CheckoutRepositoryMock.DeleteCart. %v %v", ctx, userId)
	return
}

// DeleteCartAfterCounter returns a count of finished CheckoutRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CheckoutRepositoryMock) DeleteCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.afterDeleteCartCounter)
}

// DeleteCartBeforeCounter returns a count of CheckoutRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CheckoutRepositoryMock) DeleteCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.beforeDeleteCartCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepositoryMock.DeleteCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCart *mCheckoutRepositoryMockDeleteCart) Calls() []*CheckoutRepositoryMockDeleteCartParams {
	mmDeleteCart.mutex.RLock()

	argCopy := make([]*CheckoutRepositoryMockDeleteCartParams, len(mmDeleteCart.callArgs))
	copy(argCopy, mmDeleteCart.callArgs)

	mmDeleteCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartDone returns true if the count of the DeleteCart invocations corresponds
// the number of defined expectations
func (m *CheckoutRepositoryMock) MinimockDeleteCartDone() bool {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteCartInspect logs each unmet expectation
func (m *CheckoutRepositoryMock) MinimockDeleteCartInspect() {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.DeleteCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		if m.DeleteCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepositoryMock.DeleteCart")
		} else {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.DeleteCart with params: %#v", *m.DeleteCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepositoryMock.DeleteCart")
	}
}

type mCheckoutRepositoryMockDeleteItem struct {
	mock               *CheckoutRepositoryMock
	defaultExpectation *CheckoutRepositoryMockDeleteItemExpectation
	expectations       []*CheckoutRepositoryMockDeleteItemExpectation

	callArgs []*CheckoutRepositoryMockDeleteItemParams
	mutex    sync.RWMutex
}

// CheckoutRepositoryMockDeleteItemExpectation specifies expectation struct of the CheckoutRepository.DeleteItem
type CheckoutRepositoryMockDeleteItemExpectation struct {
	mock    *CheckoutRepositoryMock
	params  *CheckoutRepositoryMockDeleteItemParams
	results *CheckoutRepositoryMockDeleteItemResults
	Counter uint64
}

// CheckoutRepositoryMockDeleteItemParams contains parameters of the CheckoutRepository.DeleteItem
type CheckoutRepositoryMockDeleteItemParams struct {
	ctx    context.Context
	userId int64
	sku    uint32
	count  uint32
}

// CheckoutRepositoryMockDeleteItemResults contains results of the CheckoutRepository.DeleteItem
type CheckoutRepositoryMockDeleteItemResults struct {
	err error
}

// Expect sets up expected params for CheckoutRepository.DeleteItem
func (mmDeleteItem *mCheckoutRepositoryMockDeleteItem) Expect(ctx context.Context, userId int64, sku uint32, count uint32) *mCheckoutRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CheckoutRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CheckoutRepositoryMockDeleteItemExpectation{}
	}

	mmDeleteItem.defaultExpectation.params = &CheckoutRepositoryMockDeleteItemParams{ctx, userId, sku, count}
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepository.DeleteItem
func (mmDeleteItem *mCheckoutRepositoryMockDeleteItem) Inspect(f func(ctx context.Context, userId int64, sku uint32, count uint32)) *mCheckoutRepositoryMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for CheckoutRepositoryMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by CheckoutRepository.DeleteItem
func (mmDeleteItem *mCheckoutRepositoryMockDeleteItem) Return(err error) *CheckoutRepositoryMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CheckoutRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CheckoutRepositoryMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &CheckoutRepositoryMockDeleteItemResults{err}
	return mmDeleteItem.mock
}

// Set uses given function f to mock the CheckoutRepository.DeleteItem method
func (mmDeleteItem *mCheckoutRepositoryMockDeleteItem) Set(f func(ctx context.Context, userId int64, sku uint32, count uint32) (err error)) *CheckoutRepositoryMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the CheckoutRepository.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the CheckoutRepository.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	return mmDeleteItem.mock
}

// When sets expectation for the CheckoutRepository.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mCheckoutRepositoryMockDeleteItem) When(ctx context.Context, userId int64, sku uint32, count uint32) *CheckoutRepositoryMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CheckoutRepositoryMock.DeleteItem mock is already set by Set")
	}

	expectation := &CheckoutRepositoryMockDeleteItemExpectation{
		mock:   mmDeleteItem.mock,
		params: &CheckoutRepositoryMockDeleteItemParams{ctx, userId, sku, count},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepository.DeleteItem return parameters for the expectation previously defined by the When method
func (e *CheckoutRepositoryMockDeleteItemExpectation) Then(err error) *CheckoutRepositoryMock {
	e.results = &CheckoutRepositoryMockDeleteItemResults{err}
	return e.mock
}

// DeleteItem implements repository.CheckoutRepository
func (mmDeleteItem *CheckoutRepositoryMock) DeleteItem(ctx context.Context, userId int64, sku uint32, count uint32) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, userId, sku, count)
	}

	mm_params := &CheckoutRepositoryMockDeleteItemParams{ctx, userId, sku, count}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_got := CheckoutRepositoryMockDeleteItemParams{ctx, userId, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("CheckoutRepositoryMock.DeleteItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the CheckoutRepositoryMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, userId, sku, count)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to CheckoutRepositoryMock.DeleteItem. %v %v %v %v", ctx, userId, sku, count)
	return
}

// DeleteItemAfterCounter returns a count of finished CheckoutRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CheckoutRepositoryMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of CheckoutRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CheckoutRepositoryMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepositoryMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mCheckoutRepositoryMockDeleteItem) Calls() []*CheckoutRepositoryMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*CheckoutRepositoryMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *CheckoutRepositoryMock) MinimockDeleteItemDone() bool {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *CheckoutRepositoryMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.DeleteItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepositoryMock.DeleteItem")
		} else {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.DeleteItem with params: %#v", *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && mm_atomic.LoadUint64(&m.afterDeleteItemCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepositoryMock.DeleteItem")
	}
}

type mCheckoutRepositoryMockGetCartItemExists struct {
	mock               *CheckoutRepositoryMock
	defaultExpectation *CheckoutRepositoryMockGetCartItemExistsExpectation
	expectations       []*CheckoutRepositoryMockGetCartItemExistsExpectation

	callArgs []*CheckoutRepositoryMockGetCartItemExistsParams
	mutex    sync.RWMutex
}

// CheckoutRepositoryMockGetCartItemExistsExpectation specifies expectation struct of the CheckoutRepository.GetCartItemExists
type CheckoutRepositoryMockGetCartItemExistsExpectation struct {
	mock    *CheckoutRepositoryMock
	params  *CheckoutRepositoryMockGetCartItemExistsParams
	results *CheckoutRepositoryMockGetCartItemExistsResults
	Counter uint64
}

// CheckoutRepositoryMockGetCartItemExistsParams contains parameters of the CheckoutRepository.GetCartItemExists
type CheckoutRepositoryMockGetCartItemExistsParams struct {
	ctx    context.Context
	userId int64
	sku    uint32
}

// CheckoutRepositoryMockGetCartItemExistsResults contains results of the CheckoutRepository.GetCartItemExists
type CheckoutRepositoryMockGetCartItemExistsResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for CheckoutRepository.GetCartItemExists
func (mmGetCartItemExists *mCheckoutRepositoryMockGetCartItemExists) Expect(ctx context.Context, userId int64, sku uint32) *mCheckoutRepositoryMockGetCartItemExists {
	if mmGetCartItemExists.mock.funcGetCartItemExists != nil {
		mmGetCartItemExists.mock.t.Fatalf("CheckoutRepositoryMock.GetCartItemExists mock is already set by Set")
	}

	if mmGetCartItemExists.defaultExpectation == nil {
		mmGetCartItemExists.defaultExpectation = &CheckoutRepositoryMockGetCartItemExistsExpectation{}
	}

	mmGetCartItemExists.defaultExpectation.params = &CheckoutRepositoryMockGetCartItemExistsParams{ctx, userId, sku}
	for _, e := range mmGetCartItemExists.expectations {
		if minimock.Equal(e.params, mmGetCartItemExists.defaultExpectation.params) {
			mmGetCartItemExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartItemExists.defaultExpectation.params)
		}
	}

	return mmGetCartItemExists
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepository.GetCartItemExists
func (mmGetCartItemExists *mCheckoutRepositoryMockGetCartItemExists) Inspect(f func(ctx context.Context, userId int64, sku uint32)) *mCheckoutRepositoryMockGetCartItemExists {
	if mmGetCartItemExists.mock.inspectFuncGetCartItemExists != nil {
		mmGetCartItemExists.mock.t.Fatalf("Inspect function is already set for CheckoutRepositoryMock.GetCartItemExists")
	}

	mmGetCartItemExists.mock.inspectFuncGetCartItemExists = f

	return mmGetCartItemExists
}

// Return sets up results that will be returned by CheckoutRepository.GetCartItemExists
func (mmGetCartItemExists *mCheckoutRepositoryMockGetCartItemExists) Return(b1 bool, err error) *CheckoutRepositoryMock {
	if mmGetCartItemExists.mock.funcGetCartItemExists != nil {
		mmGetCartItemExists.mock.t.Fatalf("CheckoutRepositoryMock.GetCartItemExists mock is already set by Set")
	}

	if mmGetCartItemExists.defaultExpectation == nil {
		mmGetCartItemExists.defaultExpectation = &CheckoutRepositoryMockGetCartItemExistsExpectation{mock: mmGetCartItemExists.mock}
	}
	mmGetCartItemExists.defaultExpectation.results = &CheckoutRepositoryMockGetCartItemExistsResults{b1, err}
	return mmGetCartItemExists.mock
}

// Set uses given function f to mock the CheckoutRepository.GetCartItemExists method
func (mmGetCartItemExists *mCheckoutRepositoryMockGetCartItemExists) Set(f func(ctx context.Context, userId int64, sku uint32) (b1 bool, err error)) *CheckoutRepositoryMock {
	if mmGetCartItemExists.defaultExpectation != nil {
		mmGetCartItemExists.mock.t.Fatalf("Default expectation is already set for the CheckoutRepository.GetCartItemExists method")
	}

	if len(mmGetCartItemExists.expectations) > 0 {
		mmGetCartItemExists.mock.t.Fatalf("Some expectations are already set for the CheckoutRepository.GetCartItemExists method")
	}

	mmGetCartItemExists.mock.funcGetCartItemExists = f
	return mmGetCartItemExists.mock
}

// When sets expectation for the CheckoutRepository.GetCartItemExists which will trigger the result defined by the following
// Then helper
func (mmGetCartItemExists *mCheckoutRepositoryMockGetCartItemExists) When(ctx context.Context, userId int64, sku uint32) *CheckoutRepositoryMockGetCartItemExistsExpectation {
	if mmGetCartItemExists.mock.funcGetCartItemExists != nil {
		mmGetCartItemExists.mock.t.Fatalf("CheckoutRepositoryMock.GetCartItemExists mock is already set by Set")
	}

	expectation := &CheckoutRepositoryMockGetCartItemExistsExpectation{
		mock:   mmGetCartItemExists.mock,
		params: &CheckoutRepositoryMockGetCartItemExistsParams{ctx, userId, sku},
	}
	mmGetCartItemExists.expectations = append(mmGetCartItemExists.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepository.GetCartItemExists return parameters for the expectation previously defined by the When method
func (e *CheckoutRepositoryMockGetCartItemExistsExpectation) Then(b1 bool, err error) *CheckoutRepositoryMock {
	e.results = &CheckoutRepositoryMockGetCartItemExistsResults{b1, err}
	return e.mock
}

// GetCartItemExists implements repository.CheckoutRepository
func (mmGetCartItemExists *CheckoutRepositoryMock) GetCartItemExists(ctx context.Context, userId int64, sku uint32) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmGetCartItemExists.beforeGetCartItemExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartItemExists.afterGetCartItemExistsCounter, 1)

	if mmGetCartItemExists.inspectFuncGetCartItemExists != nil {
		mmGetCartItemExists.inspectFuncGetCartItemExists(ctx, userId, sku)
	}

	mm_params := &CheckoutRepositoryMockGetCartItemExistsParams{ctx, userId, sku}

	// Record call args
	mmGetCartItemExists.GetCartItemExistsMock.mutex.Lock()
	mmGetCartItemExists.GetCartItemExistsMock.callArgs = append(mmGetCartItemExists.GetCartItemExistsMock.callArgs, mm_params)
	mmGetCartItemExists.GetCartItemExistsMock.mutex.Unlock()

	for _, e := range mmGetCartItemExists.GetCartItemExistsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmGetCartItemExists.GetCartItemExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartItemExists.GetCartItemExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartItemExists.GetCartItemExistsMock.defaultExpectation.params
		mm_got := CheckoutRepositoryMockGetCartItemExistsParams{ctx, userId, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartItemExists.t.Errorf("CheckoutRepositoryMock.GetCartItemExists got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartItemExists.GetCartItemExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartItemExists.t.Fatal("No results are set for the CheckoutRepositoryMock.GetCartItemExists")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmGetCartItemExists.funcGetCartItemExists != nil {
		return mmGetCartItemExists.funcGetCartItemExists(ctx, userId, sku)
	}
	mmGetCartItemExists.t.Fatalf("Unexpected call to CheckoutRepositoryMock.GetCartItemExists. %v %v %v", ctx, userId, sku)
	return
}

// GetCartItemExistsAfterCounter returns a count of finished CheckoutRepositoryMock.GetCartItemExists invocations
func (mmGetCartItemExists *CheckoutRepositoryMock) GetCartItemExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItemExists.afterGetCartItemExistsCounter)
}

// GetCartItemExistsBeforeCounter returns a count of CheckoutRepositoryMock.GetCartItemExists invocations
func (mmGetCartItemExists *CheckoutRepositoryMock) GetCartItemExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItemExists.beforeGetCartItemExistsCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepositoryMock.GetCartItemExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartItemExists *mCheckoutRepositoryMockGetCartItemExists) Calls() []*CheckoutRepositoryMockGetCartItemExistsParams {
	mmGetCartItemExists.mutex.RLock()

	argCopy := make([]*CheckoutRepositoryMockGetCartItemExistsParams, len(mmGetCartItemExists.callArgs))
	copy(argCopy, mmGetCartItemExists.callArgs)

	mmGetCartItemExists.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartItemExistsDone returns true if the count of the GetCartItemExists invocations corresponds
// the number of defined expectations
func (m *CheckoutRepositoryMock) MinimockGetCartItemExistsDone() bool {
	for _, e := range m.GetCartItemExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemExistsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemExistsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItemExists != nil && mm_atomic.LoadUint64(&m.afterGetCartItemExistsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartItemExistsInspect logs each unmet expectation
func (m *CheckoutRepositoryMock) MinimockGetCartItemExistsInspect() {
	for _, e := range m.GetCartItemExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.GetCartItemExists with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemExistsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemExistsCounter) < 1 {
		if m.GetCartItemExistsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepositoryMock.GetCartItemExists")
		} else {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.GetCartItemExists with params: %#v", *m.GetCartItemExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItemExists != nil && mm_atomic.LoadUint64(&m.afterGetCartItemExistsCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepositoryMock.GetCartItemExists")
	}
}

type mCheckoutRepositoryMockGetCartItems struct {
	mock               *CheckoutRepositoryMock
	defaultExpectation *CheckoutRepositoryMockGetCartItemsExpectation
	expectations       []*CheckoutRepositoryMockGetCartItemsExpectation

	callArgs []*CheckoutRepositoryMockGetCartItemsParams
	mutex    sync.RWMutex
}

// CheckoutRepositoryMockGetCartItemsExpectation specifies expectation struct of the CheckoutRepository.GetCartItems
type CheckoutRepositoryMockGetCartItemsExpectation struct {
	mock    *CheckoutRepositoryMock
	params  *CheckoutRepositoryMockGetCartItemsParams
	results *CheckoutRepositoryMockGetCartItemsResults
	Counter uint64
}

// CheckoutRepositoryMockGetCartItemsParams contains parameters of the CheckoutRepository.GetCartItems
type CheckoutRepositoryMockGetCartItemsParams struct {
	ctx    context.Context
	userId int64
}

// CheckoutRepositoryMockGetCartItemsResults contains results of the CheckoutRepository.GetCartItems
type CheckoutRepositoryMockGetCartItemsResults struct {
	ca1 []domain.CartItem
	err error
}

// Expect sets up expected params for CheckoutRepository.GetCartItems
func (mmGetCartItems *mCheckoutRepositoryMockGetCartItems) Expect(ctx context.Context, userId int64) *mCheckoutRepositoryMockGetCartItems {
	if mmGetCartItems.mock.funcGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("CheckoutRepositoryMock.GetCartItems mock is already set by Set")
	}

	if mmGetCartItems.defaultExpectation == nil {
		mmGetCartItems.defaultExpectation = &CheckoutRepositoryMockGetCartItemsExpectation{}
	}

	mmGetCartItems.defaultExpectation.params = &CheckoutRepositoryMockGetCartItemsParams{ctx, userId}
	for _, e := range mmGetCartItems.expectations {
		if minimock.Equal(e.params, mmGetCartItems.defaultExpectation.params) {
			mmGetCartItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartItems.defaultExpectation.params)
		}
	}

	return mmGetCartItems
}

// Inspect accepts an inspector function that has same arguments as the CheckoutRepository.GetCartItems
func (mmGetCartItems *mCheckoutRepositoryMockGetCartItems) Inspect(f func(ctx context.Context, userId int64)) *mCheckoutRepositoryMockGetCartItems {
	if mmGetCartItems.mock.inspectFuncGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("Inspect function is already set for CheckoutRepositoryMock.GetCartItems")
	}

	mmGetCartItems.mock.inspectFuncGetCartItems = f

	return mmGetCartItems
}

// Return sets up results that will be returned by CheckoutRepository.GetCartItems
func (mmGetCartItems *mCheckoutRepositoryMockGetCartItems) Return(ca1 []domain.CartItem, err error) *CheckoutRepositoryMock {
	if mmGetCartItems.mock.funcGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("CheckoutRepositoryMock.GetCartItems mock is already set by Set")
	}

	if mmGetCartItems.defaultExpectation == nil {
		mmGetCartItems.defaultExpectation = &CheckoutRepositoryMockGetCartItemsExpectation{mock: mmGetCartItems.mock}
	}
	mmGetCartItems.defaultExpectation.results = &CheckoutRepositoryMockGetCartItemsResults{ca1, err}
	return mmGetCartItems.mock
}

// Set uses given function f to mock the CheckoutRepository.GetCartItems method
func (mmGetCartItems *mCheckoutRepositoryMockGetCartItems) Set(f func(ctx context.Context, userId int64) (ca1 []domain.CartItem, err error)) *CheckoutRepositoryMock {
	if mmGetCartItems.defaultExpectation != nil {
		mmGetCartItems.mock.t.Fatalf("Default expectation is already set for the CheckoutRepository.GetCartItems method")
	}

	if len(mmGetCartItems.expectations) > 0 {
		mmGetCartItems.mock.t.Fatalf("Some expectations are already set for the CheckoutRepository.GetCartItems method")
	}

	mmGetCartItems.mock.funcGetCartItems = f
	return mmGetCartItems.mock
}

// When sets expectation for the CheckoutRepository.GetCartItems which will trigger the result defined by the following
// Then helper
func (mmGetCartItems *mCheckoutRepositoryMockGetCartItems) When(ctx context.Context, userId int64) *CheckoutRepositoryMockGetCartItemsExpectation {
	if mmGetCartItems.mock.funcGetCartItems != nil {
		mmGetCartItems.mock.t.Fatalf("CheckoutRepositoryMock.GetCartItems mock is already set by Set")
	}

	expectation := &CheckoutRepositoryMockGetCartItemsExpectation{
		mock:   mmGetCartItems.mock,
		params: &CheckoutRepositoryMockGetCartItemsParams{ctx, userId},
	}
	mmGetCartItems.expectations = append(mmGetCartItems.expectations, expectation)
	return expectation
}

// Then sets up CheckoutRepository.GetCartItems return parameters for the expectation previously defined by the When method
func (e *CheckoutRepositoryMockGetCartItemsExpectation) Then(ca1 []domain.CartItem, err error) *CheckoutRepositoryMock {
	e.results = &CheckoutRepositoryMockGetCartItemsResults{ca1, err}
	return e.mock
}

// GetCartItems implements repository.CheckoutRepository
func (mmGetCartItems *CheckoutRepositoryMock) GetCartItems(ctx context.Context, userId int64) (ca1 []domain.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetCartItems.beforeGetCartItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartItems.afterGetCartItemsCounter, 1)

	if mmGetCartItems.inspectFuncGetCartItems != nil {
		mmGetCartItems.inspectFuncGetCartItems(ctx, userId)
	}

	mm_params := &CheckoutRepositoryMockGetCartItemsParams{ctx, userId}

	// Record call args
	mmGetCartItems.GetCartItemsMock.mutex.Lock()
	mmGetCartItems.GetCartItemsMock.callArgs = append(mmGetCartItems.GetCartItemsMock.callArgs, mm_params)
	mmGetCartItems.GetCartItemsMock.mutex.Unlock()

	for _, e := range mmGetCartItems.GetCartItemsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetCartItems.GetCartItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartItems.GetCartItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartItems.GetCartItemsMock.defaultExpectation.params
		mm_got := CheckoutRepositoryMockGetCartItemsParams{ctx, userId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartItems.t.Errorf("CheckoutRepositoryMock.GetCartItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartItems.GetCartItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartItems.t.Fatal("No results are set for the CheckoutRepositoryMock.GetCartItems")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetCartItems.funcGetCartItems != nil {
		return mmGetCartItems.funcGetCartItems(ctx, userId)
	}
	mmGetCartItems.t.Fatalf("Unexpected call to CheckoutRepositoryMock.GetCartItems. %v %v", ctx, userId)
	return
}

// GetCartItemsAfterCounter returns a count of finished CheckoutRepositoryMock.GetCartItems invocations
func (mmGetCartItems *CheckoutRepositoryMock) GetCartItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItems.afterGetCartItemsCounter)
}

// GetCartItemsBeforeCounter returns a count of CheckoutRepositoryMock.GetCartItems invocations
func (mmGetCartItems *CheckoutRepositoryMock) GetCartItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItems.beforeGetCartItemsCounter)
}

// Calls returns a list of arguments used in each call to CheckoutRepositoryMock.GetCartItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartItems *mCheckoutRepositoryMockGetCartItems) Calls() []*CheckoutRepositoryMockGetCartItemsParams {
	mmGetCartItems.mutex.RLock()

	argCopy := make([]*CheckoutRepositoryMockGetCartItemsParams, len(mmGetCartItems.callArgs))
	copy(argCopy, mmGetCartItems.callArgs)

	mmGetCartItems.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartItemsDone returns true if the count of the GetCartItems invocations corresponds
// the number of defined expectations
func (m *CheckoutRepositoryMock) MinimockGetCartItemsDone() bool {
	for _, e := range m.GetCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItems != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartItemsInspect logs each unmet expectation
func (m *CheckoutRepositoryMock) MinimockGetCartItemsInspect() {
	for _, e := range m.GetCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.GetCartItems with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		if m.GetCartItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CheckoutRepositoryMock.GetCartItems")
		} else {
			m.t.Errorf("Expected call to CheckoutRepositoryMock.GetCartItems with params: %#v", *m.GetCartItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItems != nil && mm_atomic.LoadUint64(&m.afterGetCartItemsCounter) < 1 {
		m.t.Error("Expected call to CheckoutRepositoryMock.GetCartItems")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CheckoutRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToCartInspect()

		m.MinimockDeleteCartInspect()

		m.MinimockDeleteItemInspect()

		m.MinimockGetCartItemExistsInspect()

		m.MinimockGetCartItemsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CheckoutRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CheckoutRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockDeleteCartDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockGetCartItemExistsDone() &&
		m.MinimockGetCartItemsDone()
}
